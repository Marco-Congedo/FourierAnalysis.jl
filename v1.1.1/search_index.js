var documenterSearchIndex = {"docs":
[{"location":"spectra/#spectra.jl","page":"Spectral Estimations","title":"spectra.jl","text":"","category":"section"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Spectra objects created by FourierAnalysis are incapsulated in the following structure:","category":"page"},{"location":"spectra/#Spectra","page":"Spectral Estimations","title":"Spectra","text":"","category":"section"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Categories: data objects, FDobjects","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"struct Spectra\n    y           :: AbstractArray{T} where T<:Real\n    sr          :: Int\n    wl          :: Int\n    DC          :: Bool\n    taper       :: String\n    flabels     :: Vector{T} where T<:Union{Real, Int}\n    func        :: Function\n    smoothing   :: Smoother\nend","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Fields:","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"y: a real vector holding one spectrum, or a real matrix holding several spectra in its columns.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"sr: the sampling rate of the data on which the spectra have been estimated.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"wl: the FFT window length used for estimating the spectra.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"DC: if true, the first row of y holds the DC level, otherwise it holds the first positive frequency. Thus, if DC is false, the first dimension of y is equal to wl2 (integer division), otherwise it is equal to (wl2)+1 (see Overview). In all constructors it is false by default.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"taper: the time-domain tapering window used for FFT computation, as a string, with parameters in parentheses for Slepian's dpss. See tapers.jl.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"flabels: a vector holding all Fourier discrete frequencies in Hz. Those are the frequency labels for the rows of y. If DC is true, the first label is 0, otherwise it is the first positive frequency, which is equal to the frequency resolution srwl.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"func: a function applied element-wise to the spectra. In all constructors the default is the identity (do-nothing) function.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"smoothing: a Smoother flag indicating whether the spectra have been smoothed across adjacent frequencies. If no smoothing has been applied, it is equal to noSmoother, which is the default in all constructors.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Note: In Julia the fields are accessed by the usual dot notation, e.g., you may verify that for Spectra object S,","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"length(S.flabels) == size(S.y, 1) == (S.wl/2)+S.DC","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"A vector of Spectra objects is of type SpectraVector.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Methods for Spectra and SpectraVector objects","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"method Spectra SpectraVector\nbands ‚úî ‚úî\nextract ‚úî ‚úî\nmean ‚úî ‚úî\nsmooth ‚úî ‚úî\nsameParams  ‚úî","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Generic Constructors:","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"In order to construct a Spectra object from univariate and multivariate data, FourierAnalysis provides two spectra constuctors, which is what you will use in practice most of the time.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Manual constructors are also possible, for which you have to provide appropriate arguments. The default manual constructor of Spectra objects is","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Spectra(y, sr, wl, DC, taper, flabels, func, smoothing).","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Other constructors are also provided:","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Spectra(y, sr, wl, DC, tapers)","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"generates the appropriate flabels, set func to identity (do-nothing) and smoothing to noSmoother;","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Spectra(y, sr, wl, taper)","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"is like the constructor here above, but also set DC to false;","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Spectra(ùôé::CrossSpectra;\n        func::Function=identity)","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"creates a Spectra object extracting the spectra from a CrossSpectra object. If a function is provided with the func argument, this function is applied element-wise to the spectra. For instance,","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"func=sqrt will extract amplitude spectra,\nfunc=log will extract log-spectra,\nfunc=decibel will extract spectra in deciBels (see decibel).","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"By default the identity (do-nothing) function is applied, thus (power) spectra are extracted;","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"note: Nota Bene\nIf the CrossSpectra object is non-linear, the spectra are uniformly equal to 1.0. See crossSpectra.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Spectra(ùôé::CrossSpectraVector;\n        func::Function=identity)","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"create a SpectraVector object from a CrossSpectraVector object, calling the constructor here above for all crossSpectra objects hold by ùôé.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"Constructors from data:","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"note: Goertzel's algorithms\nWhen the spectrum is recquired only at one or a few discrete Fourier coefficients, Goertzel's algorithhms may be a more efficient option. See unit goertzel.jl.","category":"page"},{"location":"spectra/","page":"Spectral Estimations","title":"Spectral Estimations","text":"spectra","category":"page"},{"location":"spectra/#FourierAnalysis.spectra","page":"Spectral Estimations","title":"FourierAnalysis.spectra","text":"(1)\nfunction spectra( X     :: Union{Vector{T}, Matrix{T}},\n                  sr    :: Int,\n                  wl    :: Int;\n            tapering  :: Union{Taper, TaperKind} = harris4,\n            planner   :: Planner                 = getplanner,\n            slide     :: Int                     = 0,\n            DC        :: Bool                    = false,\n            func      :: Function                = identity, # equal to x->x\n            smoothing :: Smoother                = noSmoother,\n            ‚è©       :: Bool                    = true) where T<:Real\n\n(2)\nfunction spectra( ùêó   :: Vector{Matrix{T}},\n            < same argument sr, ..., ‚è© of method (1) > where T<:Real\n\n(1)\n\nConstruct a Spectra object from real univariate or multivariate data. Given sampling rate sr and epoch length wl, compute the Welch power spectra of a vector (univariate) or of a data matrix (multivariate) X of dimension txn, where t is the number of samples (rows) and n is the number of time-series (columns).\n\nThe spectra are hold in the .y field of the created object. If X is a vector, .y is a vector, whereas if X is a matrix, .y is a matrix holding in its columns the spectra of the signals in the columns of X. The size of the spectra depends on the DC optional keyword argument (see below), as reported in the documentation of the Spectra structure.\n\nOptional Keyword Arguments:\n\ntapering: this is a tapering object of type Taper or a tapering window kind of type TaperKind. By default the harris4 tapering window is used. If no tapering is sought, pass as argument tapering=rectangular. This same syntax is the most convenient way to specify all simple tapering window, e.g., tapering=hann, tapering=hamming, etc. For discrete prolate spheroidal sequences (dpss) multi-tapering, use instead the slepians constructor, e.g., pass as argument something like tapering=slepians(sr, wl, 2).\n\nplanner: this is an instance of the Planner object, holding the forward FFTW plan used to compute the FFTs. By default the planner is computed by this method, but it can be passed as an argumet here if it is pre-computed. This is interesting if this function is to be invoked repeatedly.\n\nslide: this is the number of samples the windows slide on (Welch method). By default the number of samples is chosen to allow 50% overlap.\n\nDC: if true, the spectrum/a of the DC level is returned in the first row of y (see the fields of the Spectra object), otherwise (default) the rows in y start with the first positive discrete frequency, that is, srwl Hz.\n\nfunc: this is a function that operate element-wise to transfrom the power spectra before returning them, including anonymous functions. Common choices are:\n\nfunc=sqrt return the amplitude spectra,\nfunc=log return the log-power spectra,\nfunc=decibel return the power spectra in deciBels (see decibel),\n\nBy default no function is applied and the power spectra are returned. If smoothing has been requested (see below), it is applied after the function.\n\nsmoothing: it applies a smoothing function of type Smoother to the spectra across adjacent frequencies. By default no smoothing is applied.\n\n‚è©: if true (default), the method run in multi-threaded mode across the series in X if the number of series is at least twice the number of threads Julia is instructed to use. See Threads.\n\n(2)\n\nConstruct a SpectraVector object from a vector of real univariate (vectors) or multivariate data (matrices). Compute the spectra as per method (1) for all k data vectors or data matrices in ùêó.\n\nIf ùêó holds data matrices, the k matrices in ùêó must have the same number of columns (i.e., the same number of time series), but may have any number of (at least wl) rows (samples). All other arguments have the same meaning as in method (1), with the following differences:\n\n‚è©: if true (default), the method run in multi-threaded mode across the   k data matrices if k is at least twice the number of threads Julia   is instructed to use, otherwise this method attempts to run each spectra   estimation in multi-threaded mode across series as per method (1).   See Threads.\nIf a planner is not explicitly passed as an argument,   the FFTW plan is computed once and applied for all spectral estimations.\n\nSee: Spectra, plot spectra.\n\nSee also: crossSpectra, coherence, goertzel.jl.\n\nExamples:\n\nusing FourierAnalysis\n\n###################################################################\n\n# (1)\n\n# Check that correct amplitude spectra is returned at all discrete\n# Fourier Frequency (using a rectangular taper).\n# Sinusoids are created at all frequencies with amplitude 10 at the\n# first frequency and then incrementing by 10 units along frequencies.\n# NB when t is even, correct amplitude for the last frequency is obtained\n# only if the sinusoidal has a particular phase.\n\nsr, t, wl= 16, 32, 16\nV=Matrix{Float64}(undef, t, wl)\nfor i=1:wl V[:, i]=sinusoidal(10*i, b2f(i, sr, t), sr, t, œÄ/6) end\n\n# using FFTW.jl only\nP=plan_rfft(V, 1)*(2/t);\nŒ£=abs.(P*V)\nusing Plots\nbar(Œ£[brange(t, DC=true), :], labels=\"\")\n\n# using FourierAnalysis.jl\nŒ£2=spectra(V, sr, t; tapering=rectangular, func=‚àö, DC=true)\nusing Plots\nbar(Œ£2.y[brange(t, DC=true), :], labels=\"\")\n\n#############################################################################\n\n### Check amplitude spectra on long signals obtained by welch methods\n# one sinusoidal is at an exact discrete Fourier Frequency and the other not\n# Rectangular window\nsr, t, f, a = 128, 128, 10, 0.5\nv=sinusoidal(a, f, sr, t*16)+sinusoidal(a, f*3.5+0.5, sr, t*16)+randn(t*16);\nŒ£=spectra(v, sr, t; tapering=rectangular, func=‚àö)\nbar(Œ£.y, labels=\"rectangular\")\n\n# harris4 window (default)\nŒ£2=spectra(v, sr, t; func=‚àö)\nbar!(Œ£2.y, labels=\"harris4\")\n\n#smooth spectra\nŒ£3=smooth(blackmanSmoother, Œ£2)\nbar!(Œ£3.y, labels=\"smoothed\")\n\n#############################################################################\n\nfunction generateSomeData(sr::Int, t::Int; noise::Real=1.)\n    # four sinusoids of length t samples and sr sampling rate\n    # peak amplitude: 0.7, 0.6, 0.5, 0.4\n    # frequency:        5,   7,  13,  27\n    # phase:            0, œÄ/4, œÄ/2,   œÄ\n    v1=sinusoidal(0.7, 5,  sr, t, 0)\n    v2=sinusoidal(0.6, 7,  sr, t, œÄ/4)\n    v3=sinusoidal(0.5, 13, sr, t, œÄ/2)\n    v4=sinusoidal(0.4, 27, sr, t, œÄ)\n    return hcat(v1, v2, v3, v4) + (randn(t, 4)*noise)\nend\n\nsr, wl, t = 128, 512, 8192\nX=generateSomeData(sr, t)\n# multivariate data matrix 8192x4\n\n# compute spectra\nS=spectra(X, sr, wl)\n\n# check the spectrum of first series\nS.y[:, 1]\n\n# gather some plot attributes to get nice plots\nusing Plots.Measures\nspectraArgs=(fmax = 32,\n             left_margin = 2mm,\n             bottom_margin = 2mm,\n             xtickfont = font(11, \"Times\"),\n             ytickfont = font(11, \"Times\"))\nplot(S; spectraArgs...)\nplot(S; xspace=2, spectraArgs...)\n\n# use a custom simple taperig window\nS=spectra(X, sr, wl; tapering=riesz)\n\n# use Slepian's multi-tapering\nS=spectra(X, sr, wl; tapering=slepians(sr, wl, 1.5))\n\n# construct with smoothing\nS=spectra(X, sr, wl; tapering=slepians(sr, wl, 1.5), smoothing=hannSmoother)\n\n# compute Amplitude Spectra instead\nS=spectra(X, sr, wl; tapering=slepians(sr, wl, 1.5), func=‚àö)\n\n# plot Aplitude spectra\nplot(S; ytitle=\"Amplitude\", spectraArgs...)\n\n# smooth the spectra a-posteriori\nS=smooth(blackmanSmoother, S)\n\n# extract spectra in range (8Hz to 12Hz)\ne=extract(S, (8, 12))\n\n# extract spectra in range (8Hz to 12Hz) for series 1 and 2\ne=extract(S, (8, 12))[:, 1:2]\n\n# extract the spectra at 10Hz only (1 bin per series)\ne=extract(S, 10)\n\n# average spectra in the 8Hz-12Hz range\nbar(mean(S, (8.0, 12.0)))\n\n# average across series of the average spectra in the 8Hz-12Hz range\nmean(mean(S, (8.0, 12.0)))\n\n# average spectrum across all frequencies for each series\nbar(mean(S, :))\n\n# average spectra in equally-spaced 2Hz-band-pass regions for all series\nplot(bands(S, 2))\n\n# average spectra in equally-spaced 2Hz-band-pass regions for series 1 and 2\nplot(bands(S, 2)[:, 1:2])\n\n# (2)\n\n# generate 3 multivariate data matrices 8192x4\nX=[generateSomeData(sr, t) for i=1:3]\n\n# Now the call to the spectra function will generate 3 Spectra objects\nS=spectra(X, sr, wl)\nplot(S[1]; spectraArgs...)\nplot(S[2]; spectraArgs...)\nplot(S[3]; spectraArgs...)\n\n# when you want to compute the spectra of many data matrices you may want\n# to do it using a fast FFTW plan (wait up to 10s for computing the plan)\nplan=Planner(plan_exhaustive, 10.0, wl)\nS=spectra(X, sr, wl; planner=plan)\n\n# how faster is this?\nusing BenchmarkTools\n@benchmark(spectra(X, sr, wl))\n@benchmark(spectra(X, sr, wl; planner=plan))\n\n\n# average spectra in range (8Hz-12Hz) for all series of all objects\nM=mean(S, (8, 12))\n\n# plot the average spectrum across all series for the three objects\n# using Julia standard mean function\nplot(mean(S[1].y[:, i] for i=1:size(S[1].y, 2)))\nplot!(mean(S[2].y[:, i] for i=1:size(S[2].y, 2)))\nplot!(mean(S[3].y[:, i] for i=1:size(S[3].y, 2)))\n\n# average spectra in range (4Hz-32.5Hz) across objects for the 4 series\nplot(mean(mean(S, (4, 32.5))))\n\n# extract spectra in range (8Hz-12Hz) for all series and all subjects\nextract(S, (8, 12))\n\n# if you enter en illegal range, nothing will be done and you will get\n# an error in the REPL explaining what is wrong in your argument\nextract(S, (0, 12))\nmean(S, (1, 128))\n\n# extract 4Hz-band-pass average spectra for all series and all objects\nbands(S, 4)\n\n# Apply smoothing in the spectra computations\nS=spectra(X, sr, t; smoothing=blackmanSmoother)\nplot(S[1]; spectraArgs...)\nplot(S[2]; spectraArgs...)\nplot(S[3]; spectraArgs...)\n\n# plot spectra in in 1Hz band-pass regions for all series in S[1]\nplot(bands(S[1], 1))\n\n# use slepian multi-tapering\nS=spectra(X, sr, wl; tapering=slepians(sr, wl, 1.))\nplot(S[1]; spectraArgs...)\n\n# average spectra across objects\nplot(mean(s.y for s ‚àà S))\n\n\n\n\n\n\n\n","category":"function"},{"location":"MainModule/#MainModule","page":"Main Module","title":"MainModule","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"This is the main unit containing the PosDefManifold module (FourierAnalysis.jl).","category":"page"},{"location":"MainModule/#dependencies","page":"Main Module","title":"dependencies","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"standard Julia packages external packages\nLinearAlgebra FFTW\nStatistics AbstractFFTs\n RecipesBase\n DSP","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"The main module does not contains functions, but it declares all types and objects holding data (named data objects) used in all units.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"Contents\ntypes\ndata objects\ntips & tricks","category":"page"},{"location":"MainModule/#types","page":"Main Module","title":"types","text":"","category":"section"},{"location":"MainModule/#fInterval","page":"Main Module","title":"fInterval","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"fInterval = Union{IntOrReal,Tuple{IntOrReal, IntOrReal}, Colon}","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"In several functions you are allowed to select a frequency range (in Hz). This can be","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"a single frequency (in Hz), given as an integer or a real number, e.g., 10,\na 2-tuple of integers or reals holding the lower and upper frequency limit (in Hz), e.g. (8, 10.5),\na colon, to indicate as usual in Julia all available frequencies.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"note: Meaning of 'frequencies' in different domains\nFrequency ranges are used as argument in the functions mean, extract, meanAmplitude, concentration, meanDirection, comodulation and coherence. They apply both to frequency domain and to time-frequency domain data. In the frequency domain, the frequencies are the Fourier discrete frequencies with resolution srwl, with or without the DC level in the first position, depending on how the object has been constructed. In the time-frequency domain, the frequencies actually are the center frequencies of the filter bank used for constructing the object. Thus, the actual frequencies actually contained in a given position depends on the bandwidth argument used to construct the oject. See filterbank.","category":"page"},{"location":"MainModule/#tInterval","page":"Main Module","title":"tInterval","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"tInterval = Union{Int, Tuple{Int, Int}, Colon}","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"In several functions you are allowed to select a time range (in samples). This can be","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"a single sample, given as an integer, e.g., 16,\na 2-tuple of integers holding the lower and upper time limit (in sampes), e.g. (1, 120),\na colon, to indicate as usual in Julia all available samples.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"These ranges are used as argument in the same functions where fInterval ranges are used. Obviously, they apply only to time-frequency domain data.","category":"page"},{"location":"MainModule/#Smoother","page":"Main Module","title":"Smoother","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"@enum Smoother begin\n    noSmoother       = 1\n    hannSmoother     = 2\n    hammingSmoother  = 3\n    blackmanSmoother = 4\nend","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"An instance of this type is requested by the smooth function, and as an optional keyword argument by several constructors. It apply both to objects created in the frequency domain and in the time-frequency domain.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"noSmoother corresponds to no smoothing.\nhannSmoother is the Hann smoothing window (3-points)\nhammingSmoother is the Hamming smoothing window (3-points)\nblackmanSmoother is the Blackman smoothing window (5-points)","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"See smooth for details on these windows.","category":"page"},{"location":"MainModule/#SpectraVector","page":"Main Module","title":"SpectraVector","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of Spectra objects.","category":"page"},{"location":"MainModule/#CrossSpectraVector","page":"Main Module","title":"CrossSpectraVector","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of CrossSpectra objects.","category":"page"},{"location":"MainModule/#CoherenceVector","page":"Main Module","title":"CoherenceVector","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of Coherence objects.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"CoherenceVector‚ÇÇ","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of CoherenceVector objects.","category":"page"},{"location":"MainModule/#TFAnalyticSignalVector","page":"Main Module","title":"TFAnalyticSignalVector","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of TFAnalyticSignal objects.","category":"page"},{"location":"MainModule/#TFAmplitudeVector","page":"Main Module","title":"TFAmplitudeVector","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of TFAmplitude objects.","category":"page"},{"location":"MainModule/#TFPhaseVector","page":"Main Module","title":"TFPhaseVector","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of TFPhase objects.","category":"page"},{"location":"MainModule/#FDobjects","page":"Main Module","title":"FDobjects","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"An object in the frequency domain (FD), that is, the union of Spectra, CrossSpectra and Coherence objects.","category":"page"},{"location":"MainModule/#FDobjectsVector","page":"Main Module","title":"FDobjectsVector","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of objects in the frequency domain (FD), that is, the union of SpectraVector, CrossSpectraVector and CoherenceVector types.","category":"page"},{"location":"MainModule/#TFobjects","page":"Main Module","title":"TFobjects","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"An object in the time-frequency (TF) domain, that is, the union of TFAnalyticSignal, TFAmplitude, TFPhase objects.","category":"page"},{"location":"MainModule/#TFobjectsVector","page":"Main Module","title":"TFobjectsVector","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"A vector of objects in the time-frequency (TF) domain, that is, the union of TFAnalyticSignalVector, TFAmplitudeVector and TFPhaseVector types.","category":"page"},{"location":"MainModule/#data-objects","page":"Main Module","title":"data objects","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"FourierAnalysis creates an operator object, the Planner, which is used to create FFTW plans for FFT computations, and several data objects. All of them are Julia structures. Data objects all have a corresponding vector type:","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"data objects domain vector type\nTaper time none\nSpectra frequency SpectraVector\nCrossSpectra frequency CrossSpectraVector\nCoherence frequency CoherenceVector\nTFAnalyticSignal time-frequency TFAnalyticSignalVector\nTFAmplitude time-frequency TFAmplitudeVector\nTFPhase time-frequency TFPhaseVector","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"For all data objects, FourierAnalysis overwrites the Julia Base.show function to display in the REPL relevant information about the name and value of the struct's fields in an easily-readable tabular form.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"The field holding the data of all data objects is consistently named .y. As a summary, this is what .y holds in all data objects:","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"Taper: for all simple tapers, a real t-vector holding the tapering window. For Slepians tapers (multi-tapering), a real txh matrix where each column holds the tapering window for one of the h Slepian tapering windows.\nSpectra: a real fxn matrix, where f is the number of Fourier discrete frequencies and n the number of time-series. Each column of y holds the spectrum for the corresponding time-series. In the case of one time-series only, y is a vector.\nCrossSpectra: a f-vector of complex nxn matrices  where f is the number of Fourier discrete frequencies and n1 the number of time-series that have generated the cross-spectra. Each matrix is the cross-spectral matrix for the corresponding frequency.\nCoherence: a f-vector of real nxn matrices  where f is the number of Fourier discrete frequencies and n1 the number of series that have generated the coherence. Each matrix is the coherence matrix for the corresponding frequency.\nTFAnalyticSignal: a complex fxt matrix, where f is the number of band-pass regions of the filter bank used to generate the analytic signal and t is the number of time samples (time-frequency representation).\nTFAmplitude: a real fxt matrix, where f is the number of band-pass regions of the filter bank used to generate the amplitude and t is the number of time samples (time-frequency representation).\nTFPhase: a real fxt matrix, where f is the number of band-pass regins  of the filter bank used to generate the phase and t is the number of time samples (time-frequency representation).","category":"page"},{"location":"MainModule/#tips-and-tricks","page":"Main Module","title":"tips & tricks","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"See recipes.jl for tips on how to plot tapering windows, spectra and time-frequency data.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"By convention, the frequency dimension of data arrays in data objects is always the first dimension. For instance, the data of multivariate Spectra and of all time-frequency objects (TFobjects), that is, TFAnalyticSignal, TFAmplitude and TFPhase, is a matrix in which the first dimension unrolls frequencies. This is the case also for CrossSpectra and Coherence objects, which data is a vector of cross-spectral or coherence matrices across frequencies.","category":"page"},{"location":"MainModule/#window-length-in-FFTW","page":"Main Module","title":"window length in FFTW","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"For effective use of the FFTW package, keep in mind that in FFTW the window length wl does not need to be a power of two, however FFTW is best for window lengths of the form 2^a 3^b 5^c 7^d 11^e  13^f, where e+f is either 0 or 1,  and the other exponents are arbitrary.","category":"page"},{"location":"MainModule/#derive-your-own-time-frequency-measures","page":"Main Module","title":"derive your own time-frequency measures","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"All functions implemented in unit timefrequencyuni.jl and timefrequencybi.jl allow to compute time-frequency measures averaging across several analytic signal objects. For each analytic signal you can extract a time-frequency region passing with argument mode the extract function (default) or the average in such a region passing with argument mode the mean function.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"Argument func allows you to apply any function to the extracted regions or means. Using this you can obtain a lot of new averaging procedures. As an example, suppose that you want to use the meanAmplitude of a TFAnalyticSignalVector object, but instead of the arithmetic mean of the amplitude you want to compute the geometric mean of the power. You will then pass as argument to the meanAmplitude function func=x->log.(x.^2) and take the exp. function of the output. It is as simple as that and works both using the mode=extract argument (default) or the mode=mean argument.","category":"page"},{"location":"MainModule/#Threads","page":"Main Module","title":"Threads","text":"","category":"section"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"Some functions in FourierAnalysis calls BLAS routine implicitly via Julia. You can set the number of threads the BLAS library should use by:","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"using LinearAlgebra\nBLAS.set_num_threads(n)","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"where n is the number of threads. By default, FourierAnalysis reserves to BLAS all CPU threads available on your computer (given by the output of Sys.CPU_THREADS). The number of threads used by Julia for multi-threaded computations is given by the output of Threads.nthreads(). In Windows this latter number of threads is set to half the available threads. In Linux and OSX defaults to one and is controlled by an environment variable, i.e.,","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"export JULIA_NUM_THREADS=4","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"In Linux, working with the Atom IDE, you also have to set to global the field found in Atom under Settings(or Preferences)/julia-client/Settings/Julia Options/Number of Threads.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"In Windows, set the desired number of threads in the settings of the julia-client Juno package.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"See this post, this post and julia doc on threads.","category":"page"},{"location":"MainModule/","page":"Main Module","title":"Main Module","text":"Notice that FourierAnalysis features many multi-threaded functions and these may allow a gain in computation time only if Julia is instructed to use at least two threads.","category":"page"},{"location":"hilbert/#hilbert.jl","page":"Hilbert Transform","title":"hilbert.jl","text":"","category":"section"},{"location":"hilbert/","page":"Hilbert Transform","title":"Hilbert Transform","text":"This unit implements analytic signal estimations using the fftw.jl unit for computing the Hilbert transform","category":"page"},{"location":"hilbert/","page":"Hilbert Transform","title":"Hilbert Transform","text":"analyticsignal","category":"page"},{"location":"hilbert/#FourierAnalysis.analyticsignal","page":"Hilbert Transform","title":"FourierAnalysis.analyticsignal","text":"   (1)\n   function analyticsignal( X  :: Union{Vector{T}, Matrix{T}},\n                            wl :: Int     = size(X, 1);\n                        nonlinear :: Bool    =  false,\n                        planner   :: Planner =  getplanner,\n                        ‚è©       :: Bool    =  true) where T<:Real\n\n   (2)\n   function analyticsignal( ùêó      :: Vector{Matrix{T}},\n                            wl     :: Int;\n                        nonlinear  ::  Bool      =  false,\n                        planner    ::  Planner   =  getplanner,\n                        ‚è©        ::  Bool      =  true) where T<:Real\n\n(1)\n\nCompute the analytic signal(AS) of vector X or of all column vectors of matrix X via the FFT and iFFT procedure, as explained in Marple(1999). If wl=size(X, 1) (default), use the standard method passing to the FFT and iFFT all samples in X altogether, whereas if wl<size(X, 1) a sliding-windows method is used (see below).\n\nReturn the analytic signal ùëå, a complex vector if X is a vector or a complex matrix holding in its columns the analytic signal of the columns of X if X is a matrix. ùëå has the same number of samples (rows) as X.\n\nContrarely to what is done in the DSP package, the DC level of the signal is removed, therefore, if the input signal features a non-zero DC level, the real part of the AS will be equal to the input signal with the DC level removed. The imaginary part of ùëå is the Hilbert transform of such no-DC X.\n\nThe sliding-windows AS allows an efficient estimation of the AS for vectors and matrices when they are very large; it proceeds computing the AS on 50% sliding overlapping windows and forming the AS by retaining the central half of each window. The number of points effectively used to obtain the final estimation is wl√∑2 (integer division). wl must be even for using this estimation. This procedure produces edge effects, thus the first and last wl4 samples of the AS estimation should be discarded. In practice, one requires the AS of a larger data segment and trims at least wl4 samples at the beginning and end of the estimation. This is done automatically by the TFanalyticsignal function.\n\nAlso, the sliding-windows AS method creates small discontinuities at sample wl√∑4 and then every wl√∑2 samples, therefore wl should be chosen as large as possible.\n\nnote: Nota Bene\nIn order to avoid FFT computation of very long epochs, if wl > 2^14, then wl is set to 2^10. Below this limit, as long as the computations are feasable, use the standard method. If you absolutely need to use the sliding-windows method, see window length in FFTW for setting efficiently argument wl.The input signal should be previously band-pass or high-pass filtered so as not to contain frequency components below the first discrete Fourier frequency obtained with windows of wl samples, that is, below sr/wl Hz, where sr is the sampling rate.\n\nOptional Keyword Arguments:\n\nnonlinear, if true, the analytic signal is normalized so that its amplitude is 10 at all points. This allow non-linear univariate and bivariate estimations (see timefrequencyuni.jl and timefrequencybi.jl).\n\nplanner is an instance of the Planner object, holding the forward and backward FFTW plans used to compute the FFTs and the iFFTs. By default the planner is computed, but it can be passed as an argumet here if it is pre-computed. This is interesting if the analyticsignal function is to be invoked repeatedly.\n\nif ‚è© is true, the method is run in multi-threaded mode across the series in X if the number of series is at least twice the number of threads Julia is instructed to use. See Threads.\n\n(2)\n\nCompute the analytic signal for all k multivariate data matrices given as a vector of matrices ùêó. Return a vector of matrices hodling the corresponding analytic signals as in method (1). The FFT and iFFT plans are computed only once. The k matrices in ùêó may have different number of columns (i.e., different number of series) and different number of rows (samples). However, the number of rows must be larger than wl for all of them.\n\nIf ‚è© is true, this method run in multi-threaded mode across the matrices in ùêó if the number of matrices is at least twice the number of threads Julia is instructed to use, otherwise it tries to run each analytic signal estimation in multi-threaded mode as per method (1). See Threads.\n\nThis function is called by the following functions operating on time-frequency reprsentations: TFanalyticsignal, TFamplitude, TFphase, meanAmplitude, concentration, meanDirection, comodulation, coherence.\n\nReferences Marple S.L. (1999) Computing the Discrete-Time Analytic Signal via FFT. IEEE Transactions on Signal Processing 47(9), 2600-3.\n\nExamples:\n\nusing FourierAnalysis, FFTW, LinearAlgebra, Statistics, Plots, DSP\nt=128; lab=[\"x\", \"real(y)\", \"imag(y)\"]\n\n# Analytic signal of one vector\nx=sinusoidal(10, 2, 128, t, œÄ/2; DC=10) # cosine\ny=analyticsignal(x)\n# note that real(y) is x without the DC level, i.e., x=real(y)+DC\nplot([x, real(y), imag(y)]; labels=lab)\n\n# make a check\ns=sinusoidal(10, 2, 128, t, 0) # sine\nnorm(s-imag(y)) # should be zero\n\n# Analytic Signal by DSP.jl\ny2=hilbert(x)\nnorm(s-imag(y2)) # should be zero\n# DSP.jl does not remove the DC level\n# thus x=real(y2) in this case\nplot([x, real(y2), imag(y2)]; labels=lab)\n\n# Analytic signal of multiple vectors\nx=hcat(x, sinusoidal(10, 3, 128, t, œÄ/2; DC=10))\ny=analyticsignal(x)\n\n# sliding-windows analytic signal of one vector\n# (note edge effects)\nx=sinusoidal(10, 2, 128, t*4, œÄ/2; DC=0)\ny=analyticsignal(x, t)\nplot([x, real(y), imag(y)]; labels=lab)\n\n# sliding-windows analytic signal of multiple vectors\nx=hcat(x, sinusoidal(10, 3, 128, t*4, œÄ/2; DC=0))\ny=analyticsignal(x, t)\n\n\n\n\n\n","category":"function"},{"location":"timefrequencyuni/#timefrequencyuni.jl","page":"TF Univariate Measures","title":"timefrequencyuni.jl","text":"","category":"section"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"This unit implements average time-frequency univariate measures based on unit timefrequency.jl and tools.jl.","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"These measures here implemented are weighted version of the measures described in Congedo (2018).","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"They can be obtained from TFAnalyticSignalVector objects or from raw data. Some of them can be obtained also from TFAmplitudeVector objects.","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"The measures are always estimated as the average across several analytic signals at all points in a time-frequency region or as the grand-average across several analytic signals of all the points in a time-frequency region. In the following an average process is denoted by angle brackets leftcdotright and is used to indicate generically both averaging processes. Analytic signal in a time-frequency region, it does not matter if this is actually a single point, a vector or a matrix, is denoted such as","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"z=x+textitiy=re^iphi,","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"where ùëñ is the imaginary unit, r=mid z mid is the amplitude (modulus) of z and phi=textrmArcTanspace (xy) the phase (argument) of z.","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"Also, w denotes non-negative weights normalized so that their average is 10. w weights the different analytic signals on which the average is computed. Setting all weights equal to 10 gives the unweighted version of all measures.","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"Some of the measures come in a linear and non-linear form. It is adopted throughout the convention of prepending 'phase' to the name of a measure to signal it is non-linear. The reason is that non-linear measures are not sensitive to amplitude, but only to phase. See Congedo (2018) for a throughout discussion.","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"The implemented measures are:","category":"page"},{"location":"timefrequencyuni/#(weighted)-mean-amplitude","page":"TF Univariate Measures","title":"(weighted) mean amplitude","text":"","category":"section"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"(w)MAmp=wleftmid z midrightbig leftwright=wleftrrightbig leftwright.","category":"page"},{"location":"timefrequencyuni/#(weighted)-concentration","page":"TF Univariate Measures","title":"(weighted) concentration","text":"","category":"section"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"(w)Con=midleftwzrightmidbig leftwright=midleftwre^iphirightmidbig leftwright.","category":"page"},{"location":"timefrequencyuni/#(weighted)-phase-concentration","page":"TF Univariate Measures","title":"(weighted) phase concentration","text":"","category":"section"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"(w)PCon=midleftwe^iphirightmidbig leftwright.","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"This is the non-linear version of the (weighted) concentration. In the litetrature it is also known as circular mean resultant length, inter-trial phase coherence, inter-trial phase clustering and phase coherence, among other names (Congedo, 2018).","category":"page"},{"location":"timefrequencyuni/#(weighted)-mean-direction","page":"TF Univariate Measures","title":"(weighted) mean direction","text":"","category":"section"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"(w)MDir=textrmArcTanspace big((leftwyrightleftwxright)big leftwrightbig)","category":"page"},{"location":"timefrequencyuni/#(weighted)-phase-mean-direction","page":"TF Univariate Measures","title":"(weighted) phase mean direction","text":"","category":"section"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"(w)PMDir=textrmArcTanspace big((leftwyrrightleftwxrright)big leftwrightbig)","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"This is the non-linear version of the (weighted) phase mean direction","category":"page"},{"location":"timefrequencyuni/","page":"TF Univariate Measures","title":"TF Univariate Measures","text":"meanAmplitude\nconcentration\nmeanDirection","category":"page"},{"location":"timefrequencyuni/#FourierAnalysis.meanAmplitude","page":"TF Univariate Measures","title":"FourierAnalysis.meanAmplitude","text":"(1)\nfunction meanAmplitude( ùêÄ      :: TFAmplitudeVector,\n                        frange :: fInterval,\n                        trange :: tInterval;\n                    mode   :: Function = extract,\n                    func   :: Function = identity,\n                    w      :: Vector   = [],\n                    check  :: Bool     = true)\n\n(2)\nfunction meanAmplitude( ùêô :: TFAnalyticSignalVector,\n                    < same arguments as method (1) >\n\n(3)\nfunction meanAmplitude( ùê±      :: Vector{Vector{T}},\n                        sr     :: Int,\n                        wl     :: Int,\n                        frange :: fInterval,\n                        trange :: tInterval,\n                     bandwidth :: IntOrReal    = 2;\n                 mode          :: Function     = extract,\n                 func          :: Function     = identity,\n                 w             :: Vector       = [],\n                 check         :: Bool         = true,\n                 filtkind      :: FilterDesign = Butterworth(2),\n                 fmin          :: IntOrReal    = bandwidth,\n                 fmax          :: IntOrReal    = sr√∑2,\n                 fsmoothing    :: Smoother     = noSmoother,\n                 tsmoothing    :: Smoother     = noSmoother,\n                 planner       :: Planner      = getplanner,\n                 ‚è©           :: Bool         = true) where T<:Real\n\n\nalias: mamp\n\n(1)\n\nGiven a TFAmplitudeVector object, estimate the (weighted) mean amplitude measure across those objects. The time-frequency planes of all the objects in ùêÄ should be congruent.\n\narguments:\n\nfrange and trange define a time-frequency region on which the estimation is sought. frange is a fInterval type and delimits center frequencies of the filter bank. trange is a tInterval type and delimits time samples. To obtain the estimation in the whole time-frequency plane use the column (:) sign for both arguments.\n\noptional keyword arguments\n\nIf mode=extract is passed (default), the measure will be computed for all points in the chosen time-frequency region. If mode=mean is passed, it will be computed on the mean of these points (grand-average). The extract and mean functions are generic methods of FourierAnalysis.\n\nNote: with mode=mean the output of the function is always a real number, whereas with mode=extract the output may be a real number, a real row or column vector or a real matrix, depending on the shape of the chosen time-frequency region.\n\nPassing a function with the func argument you can derive your own time-frequency measures.\n\nw may be a vector of non-negative real weights associated to each input object. By default the unweighted version of the measure is computed.\n\nIf check is true (default), check that if the column sign is passed\n\nas frange argument, all input objects have the same number of rows (center frequencies);\nas trange argument, all input objects have the same number of columns (time samples).\n\nIf either check fails, print an error message and return Nothing. No other range checks are performed.\n\n(2)\n\nGiven a TFAnalyticSignalVector object, compute the amplitude of all objects in ùêô and estimate the (weighted) mean amplitude measure across those objects as per method (1). In addition, since using this method all TFAnalyticSignal in ùêô must be linear, if check is true (default) and this is not the case, print an error and return Nothing. The checks on frange and trange performed by method (1) are also performed by this method.\n\n(3)\n\nEstimate the amplitude of all data vectors in ùê± calling the TFamplitude constructor and then estimate the (weighted) mean amplitude measure across the constructed amplitude objects as per method (1).\n\nfrange, trange, mode, func, w and check have the same meaning as in method (1). The other arguments are passed to the TFamplitude constructor, to which the reader is referred for their meaning.\n\nSee also: concentration, meanDirection, timefrequencybi.jl.\n\nExamples:\n\nusing FourierAnalysis\n\n# generate 100 vectors of data\nsr, t, bandwidth=128, 512, 2\nh=taper(harris4, t)\nùê±=[sinusoidal(2, 10, sr, t, 0).*h.y+randn(t) for i=1:100]\n\nùêò=TFanalyticsignal(ùê±, sr, t, bandwidth; fmax=32)\nùêÄ=TFamplitude(ùêò)\n\n# mean amplitude in a TF region from a TFAnalyticSignalVector object\nMAmp=meanAmplitude(ùêò, (4, 16), :)\nheatmap(MAmp; c=:fire) # y axis labels are not correct\n\n# mean amplitude in a TF region from a TFAmplitudeVector object\nMAmp=meanAmplitude(ùêÄ, (4, 16), :)\n\n# mean amplitude in a TF region directly from data\nMAmp=meanAmplitude(ùê±, sr, t, (4, 16), :, bandwidth)\n\n# NB: in the above, the analytic signal objects must all\n# be linear, since meanAmplitude is computed from amplitude\n# and the amplitude of non-linear analytic signal is uniformy equal to 1.\n\n# All these computations can be obtained averaging in a TF region, e.g.,\nMAmp=meanAmplitude(ùêò, (4, 16), :; mode=mean) # output a real number\n\n# and can be obtained on smoothed Amplitude, e.g.,\nMAmp=meanAmplitude(ùê±, sr, t, (4, 16), :;\n                   fsmoothing=blackmanSmoother,\n                   tsmoothing=blackmanSmoother)\n# or, equivalently, and using the alias `mamp`,\nMAmp=mamp(smooth(blackmanSmoother, blackmanSmoother, ùêÄ), (4, 16), :)\n\n# A similar syntax is used for the other univariate measures, e.g.,\n# concentration averaging in a TF region from a TFAnalyticSignalVector object\nConM=concentration(ùêò, (4, 16), (128, 384); mode=mean)\n\n# concentration in a TF region directly from data (using the alias `con`)\nConE=con(ùê±, sr, t, (4, 16), (128, 384), bandwidth; mode=extract)\nheatmap(Con; c=:fire) # y axis labels are not correct\n\nNB: ConM is not at all equivalent to mean(ConE) !\n\n# mean direction averaging in a TF region directly from data\nMDir=meanDirection(ùê±, sr, t, (4, 16), :, bandwidth; mode=mean)\n\n# mean direction in a TF region from a TFAnalyticSignalVector object\nMDir=meanDirection(ùêò, (4, 16), :)\n\n# and for the non-linear counterpart:\n# phase concentration in a TF region directly from data\nCon=concentration(ùê±, sr, t, (8, 12), :; nonlinear=true)\n\n# phase concentration at a single TF point\nCon=concentration(ùê±, sr, t, 10, 256; nonlinear=true)\n\n# phase mean direction averaging in a TF region directly from data\n# and using the alias `mdir`\nMDir=mdir(ùê±, sr, t, (8, 12), :; mode=mean, nonlinear=true)\n\n# If you try to compute a non-linear measure from a linear\n# AnalyticSignal object you will get en error (see the REPL), e.g.,\nCon=con(ùêò, (8, 12), (1, 512); mode=mean, nonlinear=true)\n\n# In order to compute non-linear measures from analytic signal objects\n# first we need to compute non-linear analytic signal objects:\nùêò=TFanalyticsignal(ùê±, sr, t, bandwidth; fmax=32, nonlinear=true)\n\n# then, we can obtain for example the phase concentration\nCon=con(ùêò, (8, 12), :; mode=mean, nonlinear=true)\n\n# and the phase mean direction\nMDir=meanDirection(ùêò, (8, 12), :; nonlinear=true)\n\n\n\n\n\n","category":"function"},{"location":"timefrequencyuni/#FourierAnalysis.concentration","page":"TF Univariate Measures","title":"FourierAnalysis.concentration","text":"(1)\nfunction concentration( ùêô       :: TFAnalyticSignalVector,\n                        frange  :: fInterval,\n                        trange  :: tInterval;\n                    nonlinear :: Bool     = false,\n                    mode      :: Function = extract,\n                    func      :: Function = identity,\n                    w         :: Vector   = [],\n                    check     :: Bool     = true)\n\n(2)\nfunction concentration( ùê±      :: Vector{Vector{T}},\n                        sr     :: Int,\n                        wl     :: Int,\n                        frange :: fInterval,\n                        trange :: tInterval,\n                     bandwidth :: IntOrReal    = 2;\n                 nonlinear  :: Bool         = false,\n                 mode       :: Function     = extract,\n                 func       :: Function     = identity,\n                 w          :: Vector       = [],\n                 check         :: Bool      = true,\n                 filtkind   :: FilterDesign = Butterworth(2),\n                 fmin       :: IntOrReal    = bandwidth,\n                 fmax       :: IntOrReal    = sr√∑2,\n                 fsmoothing :: Smoother     = noSmoother,\n                 tsmoothing :: Smoother     = noSmoother,\n                 planner    :: Planner      = getplanner,\n                 ‚è©        :: Bool         = true) where T<:Real\n\n\nalias: con\n\nIf optional keyword parameter nonlinear is false (default), estimate the (weighted) concentration measure, otherwise estimate the (weighted) phase concentration measure.\n\n(1) The desired measure is obtained averaging across the TFAnalyticSignal objects in ùêô. Since this method uses pre-computed analytic signal objects, their .nonlinear field must agree with the nonlinear argument passed to this function.\n\nfrange, trange, w, mode and func have the same meaning as in the meanAmplitude function, however keep in mind that the two possible mode functions, i.e., extract and mean, in this function operate on complex numbers.\n\nThe checks performed in the meanAmplitude function are performed here too. In addition, if check is true, also check that\n\nif nonlinear is true, all objects in ùêô are nonlinear;\nif nonlinear is false, all objects in ùêô are linear.\n\nIf either check fails, print an error message and return Nothing.\n\n(2) Estimate the analytic signal of all data vectors in ùê± calling the TFanalyticsignal constructor and then use method (1) to obtained the desired measure.\n\nfrange, trange, mode, func, w and check have the same meaning as in the meanAmplitude function. The other arguments are passed to the TFanalyticsignal constructor, to which the reader is referred for understanding their action.\n\nSee also: meanAmplitude, meanDirection, timefrequencybi.jl.\n\nExamples: see the examples of meanAmplitude function.\n\n\n\n\n\n","category":"function"},{"location":"timefrequencyuni/#FourierAnalysis.meanDirection","page":"TF Univariate Measures","title":"FourierAnalysis.meanDirection","text":"(1)\nfunction meanDirection( ùêô         :: TFAnalyticSignalVector,\n                        frange    :: fInterval,\n                        trange    :: tInterval;\n                    nonlinear :: Bool       = false,\n                    mode      :: Function   = extract,\n                    func      :: Function   = identity,\n                    w         :: Vector     = [],\n                    check     :: Bool       = true)\n\n(2)\nfunction meanDirection( ùê±      :: Vector{Vector{T}},\n                        sr     :: Int,\n                        wl     :: Int,\n                        frange :: fInterval,\n                        trange :: tInterval,\n                     bandwidth :: IntOrReal    = 2;\n                 nonlinear     :: Bool         = false,\n                 mode          :: Function     = extract,\n                 func          :: Function     = identity,\n                 w             :: Vector       = [],\n                 check         :: Bool         = true,\n                 filtkind      :: FilterDesign = Butterworth(2),\n                 fmin          :: IntOrReal    = bandwidth,\n                 fmax          :: IntOrReal    = sr√∑2,\n                 fsmoothing    :: Smoother     = noSmoother,\n                 tsmoothing    :: Smoother     = noSmoother,\n                 planner       :: Planner      = getplanner,\n                 ‚è©           :: Bool         = true) where T<:Real\n\nThis function features two methods that use exactly the same syntax as the two corresponding methods of the concentration function. All arguements have exactly the same meaning as therein. Only the output differs:\n\nif optional keyword parameter nonlinear is false (default), estimate the (weighted) mean direction measure, otherwise estimate the (weighted) phase mean direction measure.\n\nalias: mdir\n\nSee also: meanAmplitude, concentration, timefrequencybi.jl.\n\nExamples: see the examples of meanAmplitude.\n\n\n\n\n\n","category":"function"},{"location":"coherence/#coherence.jl","page":"Coherence Matrices","title":"coherence.jl","text":"","category":"section"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"FourierAnalysis estimates coherence both in the frequency domain, in this unit, and in the time-frequency domain, in unit timefrequencybi.jl.","category":"page"},{"location":"coherence/#Notation","page":"Coherence Matrices","title":"Notation","text":"","category":"section"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"The following notation will be used:","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"symbol meaning Julia function\nsuperscript ^* complex conjugate conj()\nsuperscript ^H complex conjugate transpose '\nmid cdot mid modulus abs()\nBbb R(cdot) real part of the argument real()\nBbb C(cdot) imaginary part of the argument imag()\nleftcdotright an average across argument's elements mean()","category":"page"},{"location":"coherence/#coherence-estimates","page":"Coherence Matrices","title":"coherence estimates","text":"","category":"section"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"frequency domain (FD)","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"In the FD, the input is a continuous multivariate data matrix X=x_1  x_n, where each column is a series (e.g., a time-series). Coherence estimates take the form of a nxn coherence matrix C(f) for each discrete Fourier frequency f. Those are normalized versions of the nxn cross-spectral matrices S(f) at corresponding frequencies.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Cross-spectral matrices are estimated via a Welch procedure, that is, they are averaged across windows sliding over X. The windows may be overlapping or not. Let Y_l(f) be the discrete Fourier transform at discrete Fourier frequency f of the l^th window of X. The cross-spectral matrix estimation at frequency f is then given by","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"S(f)=leftY(f)Y(f)^Hright,","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"where the average is taken across a number of sliding windows.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Therefore, coherence matrices in the FD is a measure of the synchronization between all n series of X taken pair-wise, resulting in a symmetric matrix for each discrete Fourier frequency.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"time-frequency domain (TFD)","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"There exist many time-frequency representation, e.g., those obtained using wavelets, short-time Fourier transform, etc. In FourierAnalysis time-frequency representations are obtained passing a univariate signal through a filter bank and computing the analytic signal of the filter output via the Hilbert transform. This results in a matrix with the band-pass regions of the filer bank in rows and the t time samples in columns (see filterbank and analyticsignal for details).","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"For estimating coherence in the TFD, the input is composed of two sets of k univariate data vectors ùê±_a=x_a1 x_a2x_ak and ùê±_b=x_b1 x_b2x_bk, where each element of the set is to be understood as a single window holding t samples and where the elements in corresponding positions forms pairs. Let Y_r(a) and Y_r(b) be the time-frequency analytic signal of pairs x_ar, x_br, for all r=1k. Coherence estimates also have a time-frequency representation. They are a normalized version of crossed analytic signals, which are analogous to cross-spectra and in a time-frequency plane are given by","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Z=leftY(a) odot Y(b)^*right,","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"where the average is taken across the k pairs (realizations).","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Therefore, the coherence matrix in the TFD is a measure of the synchronization between pairs ùê±_a, ùê±_b for each point in the time-frequency plane.","category":"page"},{"location":"coherence/#kinds-of-coherence","page":"Coherence Matrices","title":"kinds of coherence","text":"","category":"section"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"FourierAnalysis estimates several kinds of linear and non-linear squared coherences, simply referred to as coherence. Let i and j indicate two time series, lefts_ijright be an average cross-spectrum between i and j, and lefts_iright, lefts_jright be the auto-spectrum of i , j. In the frequency domain those are function of frequency, whereas in the time-frequency domain they are functions of both time and frequency.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Finally, for time-frequency data let w denote non-negative weights normalized so that their average is 1. Those are weights for the pairs on which the averages are computed. Setting all weights equal to 1, gives the unweighted version of all measures, which is the only supported option in the FD, since therein the average is taken across windows and since windows segmentation is arbitrary, weighting is usually meaningless.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"All kinds of coherences estimated in FourierAnalysis are summarized in the following table:","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"kind linear non-linear\ntotal leftwmid s_ij mid^2rightbig leftws_is_jright leftwmid s_ij mid^2right\nreal leftwmid Bbb R(s_ij) mid^2rightbigleftws_is_jright leftwmid Bbb R(s_ij)mid^2right\nimaginary leftwmid Bbb C(s_ij) mid^2rightbigleftws_is_jright leftwmid Bbb C(s_ij) mid^2right\ninstantaneous leftwmid Bbb R(s_ij) mid^2rightbigleftw(s_is_j-mid Bbb C(s_ij) mid^2)right leftwmid Bbb R(s_ij) mid^2rightbigleftw(1-mid Bbb C(s_ij) mid^2)right\nlagged leftwmid Bbb C(s_ij) mid^2rightbigleftw(s_is_j-mid Bbb R(s_ij) mid^2)right leftwmid Bbb C(s_ij) mid^2rightbigleftw(1-mid Bbb R(s_ij) mid^2)right","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"The linear total  coherence is the classical squared coherence measure and its non-linear counterpart is known as phase-locking value or phase coherence.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"The real coherence (Pascual-Marqui, 2007) and the imaginary coherence (Nolte et al., 2004), sum up to the total coherence.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"The lagged coherence has been proposed by Pascual-Marqui (2007). As a completion of the table, we here also define the instantaneous coherence in an analogous way.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Corresponding linear and non-linear measures are the same, but are computed on linear and non-linear cross-spectra in the FD and crossed analytic-signal in the TFD, respectively. In fact, the non-linear expressions are obtained setting s_i=s_j=1, which is the case for non-linear cross-spectra and analytic signals. See CrossSpectra and TFAnalyticSignal. For further explanations on the linearity of those objects, see Congedo (2018).","category":"page"},{"location":"coherence/#interpreting-coherence","page":"Coherence Matrices","title":"interpreting coherence","text":"","category":"section"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"The real part of the cross-spectrum, named the co-spectrum, describes the synchronous synchronization, that is, in-phase synchronization or out-of-phase synchronization. The imaginary part, named the quadrature spectrum, describes the asynchronous synchronization, that is, with a quarter of a cycle lead or lag (see Congedo, 2018). Consequently,","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"the total coherence is sensitive to all kinds of synchronization,\nthe real coherence is sensitive only to synchronous synchronization,\nthe instantaneous coherence is sensitive to all but asynchronous synchronization,\nthe imaginary coherence is sensitive only to asynchronous synchronization,\nthe lagged coherence is sensitive to all but synchronous synchronization.","category":"page"},{"location":"coherence/#Coherence","page":"Coherence Matrices","title":"Coherence","text":"","category":"section"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Categories: data objects, FDobjects","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"In the time-frequency domain coherence estimates are given as Julia Matrix objects. In the frequency-domain they are encapsulated in the following structure:","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"struct Coherence\n   <same fields of the CrossSpectra structure>\nend","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"This object has the same structure of the CrossSpectra object, with the difference that its y data field holds real matrices, whereas for cross-spectra holds complex matrices.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"By convention the diagonal elements of all FD coherence matrices are filled with 1.0. Note that the FFT coefficients for the DC level and the Nyquist frequency are real, therefore for those frequencies the identity matrix is returned for the imaginary and lagged coherence. Also, note that at these frequencies the instantaneous coherence is equal to the real coherence. In the time-frequency domain, we do not have discrete frequencies but a filter bank, thus no special behavior appears at the edges.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"A vector of Coherence objects is of type CoherenceVector.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Methods for Coherence and CoherenceVector objects","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"method Coherence CoherenceVector\nbands ‚úî ‚úî\nextract ‚úî ‚úî\nmean ‚úî ‚úî\nsmooth ‚úî ‚úî\nsameParams  ‚úî","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Generic Constructors:","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"In order to construct a Coherence object in the frequency domain from multivariate data, FourierAnalysis provides two coherence constuctors from raw data and two constuctors building coherence matrices from CrossSpectra and CrossSpectraVector objects. Those are what you will use in practice most of the time.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Manual constructors are also possible, for which you have to provide appropriate arguments. Generic constructors follow exactly the same syntax as the generic constructors of CrossSpectra objects.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"In order to estimate coherence in the time-frequency domain from sets of univariate data, FourierAnalysis provides two more coherence functions.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"Constructors from data:","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"coherence","category":"page"},{"location":"coherence/#FourierAnalysis.coherence","page":"Coherence Matrices","title":"FourierAnalysis.coherence","text":"(1)\nfunction coherence(ùôé    :: CrossSpectra;\n               allkinds :: Bool = false)\n\n(2)\nfunction coherence(ùì¢    :: CrossSpectraVector;\n               allkinds :: Bool = false,\n               check    :: Bool = true)\n\n(3)\nfunction coherence(X  :: Matrix{T},\n                   sr :: Int,\n                   wl :: Int;\n               tapering  :: Union{Taper, TaperKind} = harris4,\n               planner   :: Planner                 = getplanner,\n               slide     :: Int                     = 0,\n               DC        :: Bool                    = false,\n               nonlinear :: Bool                    = false,\n               smoothing :: Smoother                = noSmoother,\n               tril      :: Bool                    = false,\n               allkinds  :: Bool                    = false,\n               ‚è©       :: Bool                    = true) where T<:Real\n\n(4)\nfunction coherence(ùêó :: Vector{Matrix{T}},\n              < same argument sr, ..., ‚è© of method (3) > where T<:Real\n\n\n\nalias: coh\n\n(1)\n\nConstruct a Coherence object from a CrossSpectra object, allowing coherence estimates using the Welch method. All non-data fields are copied from the cross-spectra object, i.e., all fields but y, which holds the coherence matrices that are computed by this function.\n\nIf ùôé.tril is true, only the lower triangular part of the coherence matrices is computed and the matrices in y are LowerTriangular matrices, otherwise the full matrices are computed and y will hold Hermitian matrices (see LinearAlgebra).\n\nIf optional keyword argument allkinds is true, all five kinds of coherence are returned. In this case the output is a 5-tuple of Coherence objects, in the order:\n\ntotal coherence,\nreal coherence,\ninstantaneous coherence\nimaginary coherence,\nlagged coherence.\n\nIf allkinds is false (default), only the total (classical) coherence is returned as a single Coherence object.\n\n(2)\n\nConstruct a CoherenceVector object from the input CrossSpectraVector object ùì¢, allowing coherence estimates using the Welch method. This method calls method (1) for all objects in ùì¢.\n\nThe allkinds optional keyword parameter has the same meaning as in method (1). In this method if the argument is passed as true, the output is a 5-tuple of CoherenceVector objects.\n\nIf optional keyword argument check is true (default), it is checked that all CrossSpectra objects in ùì¢ have the same value in the `.sr, .wl, .DC, .taper, .nonlinear and .smoothing field. If this is not the case, an error message is printed pointing to the first field that is not identical in all objects and Nothing is returned.\n\n(3)\n\nGiven a multivariate time series data matrix X of dimension t x n, where t is the number of samples (rows) and n the number of time-series (columns), sampling rate sr and epoch length wl, compute the squared coherence matrices of X, that is, the coherence matrices at all Fourier discrete frequencies obtained from the Welch (sliding window) average cross-spectra.\n\noptioal keyword arguments:\n\nsr, wl, tapering, planner and slide have the same meaning as for the spectra function.\n\nDC, nonlinear, smoothing, tril and ‚è© have the same meaning as for the crossSpectra function, to which they apply for estimating the cross-spectra.\n\nThe allkinds optional keyword parameter has the same meaning as in method (1).\n\n(4)\n\nConstruct a CoherenceVector object from a vector of real multivariate data matrices. Compute the coherence matrices from the cross-spectral matrices estimated using the Welch method as per method (3) for all k data matrices in ùêó.\n\nThe k matrices in ùêó must have the same number of columns (i.e., the same number of time-series), but may have any number of (at least wl) rows (samples). All other arguments have the same meaning as in method (3), with the following difference:\n\n‚è©: if true (default), the method is run in multi-threaded mode across the k data matrices if k is at least twice the number of threads Julia is instructed to use, otherwise this method attempts to run each coherence estimation in multi-threaded mode across series as per method (3). See Threads.\n\nIf a Planner is not explicitly passed as an argument, the FFTW plan is computed once and applied for all coherence estimations.\n\nnote for methods (1) and (3):\n\nIf tril is false (default), the output coherence object(s) is of type Array{Hermitian,1}, which is the ‚ÑçVector type used in package PosDefManifold. Since coherence estimates are symmetric positive definite, they can be straightaway used as argument to PosDefManifold's functions, e.g., for computing matrix moves on geodesics, matrix distances, etc. and the the whole vector output to compute matrix means, spectral embedding and more.\n\nIf tril is true, the output is of type Array{LowerTriangular,1}, which is the ùïÉVector type used in PosDefManifold, that is, only the lower triangle of the coherencee is computed in order to save time and memory.\n\nnote for methods (2) and (4):\n\nIf tril is false, the output is of type Array{Array{Hermitian,1},1}, which is the ‚ÑçVector‚ÇÇ type used in PosDefManifold.\n\nIf tril is true, the output is of type Array{Array{LowerTriangular,1},1}, which is the ùïÉVector‚ÇÇ type used in PosDefManifold.\n\nSee: crossspectra.jl, Spectra, Coherence.\n\nExamples:\n\n## common code for methods (1)-(4)\n\nusing FourierAnalysis, LinearAlgebra\n\nfunction generateSomeData(sr::Int, t::Int; noise::Real=1.)\n    # four sinusoids of length t samples and sr sampling rate\n    # peak amplitude: 0.7, 0.6, 0.5, 0.4\n    # frequency:        5,   7,  13,  27\n    # phase:            0, œÄ/4, œÄ/2,   œÄ\n    v1=sinusoidal(0.7, 5,  sr, t, 0)\n    v2=sinusoidal(0.6, 7,  sr, t, œÄ/4)\n    v3=sinusoidal(0.5, 13, sr, t, œÄ/2)\n    v4=sinusoidal(0.4, 27, sr, t, œÄ)\n    return hcat(v1, v2, v3, v4) + (randn(t, 4)*noise)\nend\n\nsr, wl, t = 128, 512, 8192\n\n# (1)\n\nX=generateSomeData(sr, t) # multivariate data matrix 8192x4\n\n# cross-spectra using default harris4 tapering window\nS=crossSpectra(X, sr, wl)\n\n# Only classical coherence\nC=coherence(S)\n\n# All 5 kinds of coherence\nCtot, C2real, C3inst, C4imag, C5lag=coherence(S, allkinds=true);\nCtot\n\n# (2)\n\n# generate 3 multivariate data matrices 8192x4\nX=[generateSomeData(sr, t) for i=1:3]\n\n# cross-spectra using default harris4 tapering window\nS=crossSpectra(X, sr, wl)\n\n# Only classical coherence\nC=coherence(S)\n\n# All 5 kinds of coherence\nCtot, C2real, C3inst, C4imag, C5lag=coherence(S, allkinds=true);\nCtot\n\n# (3)\n\nX=generateSomeData(sr, t) # multivariate data matrix 8192x4\n\n# coherence using default harris4 tapering window\nC=coherence(X, sr, wl)\n\n# check the coherence matrix at frequency 5Hz\nC.y[f2b(5, sr, wl)]\n\n# coherence using hann tapering window\nC=coherence(X, sr, wl; tapering=hann)\n\n# using Slepian's multi-tapering\nC=coherence(X, sr, wl; tapering=slepians(sr, wl))\n\n# compute non-linear coherence (phase-locking value)\nC=coherence(X, sr, wl; tapering=slepians(sr, wl), nonlinear=true)\n\n# compute only the lower triangle of coherence matrices\nC=coherence(X, sr, wl; tapering=slepians(sr, wl), tril=true)\n\n# compute all five kinds of coherence\nCtot, Creal, Cinst, Cimag, Clag=coherence(X, sr, wl;\n    tapering=slepians(sr, wl), tril=true, allkinds=true);\nCtot\n\n# smooth a-posteriori the coherence\nC2=smooth(blackmanSmoother, C)\n\n# or compute coherence already smoothed\nC=coherence(X, sr, wl;\n            tapering=slepians(sr, wl), tril=true, smoothing=blackmanSmoother)\n\n# mean coherence matrix in 8Hz-12Hz range\nM=mean(C, (8, 12)) # or also M=mean(C, (8.0, 12.0))\n\n# extract all coherence matrices in 8Hz-12Hz range\nE=extract(C, (8, 12))\n\n# coherence matrices averaged in 2Hz band-pass regions\nB=bands(C, 2)\n\n# (4)\n\n# generate 3 multivariate data matrices 8192x4\nX=[generateSomeData(sr, t) for i=1:3]\n\n# The examples here below use exactly the same syntax as method (3).\n# However, since the input here is a vector of data matrices\n# and not a single data matrix, the examples here below create a vector\n# of the object created by the examples of method (3).\n# For example:\n\n# coherence using the default harris4 tapering window\n# this creates a CoherenceVector object\nC=coherence(X, sr, wl)\n\n# check the first Coherence object\nC[1]\n\n# check the coherence matrix at fr. 5Hz for the first Coherence object\nC[1].y[f2b(5, sr, wl)]\n\n# coherence using Hann tapering window\nC=coherence(X, sr, wl; tapering=hann)\n\n# using Slepian's multi-tapering\nC=coherence(X, sr, wl; tapering=slepians(sr, wl))\n\n# compute non-linear coherence\nC=coherence(X, sr, wl; tapering=slepians(sr, wl), nonlinear=true)\n\n# compute only the lower triangle of coherence matrices\nC=coherence(X, sr, wl; tapering=slepians(sr, wl), tril=true)\n\n# compute all five kinds of coherence\nCtot, Creal, Cinst, Cimag, Clag=coherence(X, sr, wl;\n    tapering=slepians(sr, wl), tril=true, allkinds=true);\nCtot\n\n# smooth a-posteriori all coherence objects in S\nC2=smooth(blackmanSmoother, C)\n\n# or compute them all already smoothed\nC=coherence(X, sr, wl; tapering=parzen, smoothing=blackmanSmoother)\n\n# mean coherence matrix in 8Hz-12Hz range for all coherence objects\nM=mean(C, (8, 12)) # or also M=mean(C, (8.0, 12.0))\n\n# grand-average mean of the above across all Coherence objects\nmeanM=mean(mean(C, (8, 12)))\n\n# extract all coherence matrices in 8Hz-12Hz range for all coherence objects\nE=extract(C, (8, 12))\n\n# grand average of coherence matrices in 8Hz-12Hz range for all coh. objects\nmeanE=mean(extract(C, (8, 12)))\n\n# coherence matrices averaged in 2Hz band-pass regions for all coh. objects\nB=bands(C, 2)\n\n# Pre-compute a FFT planner and pass it as argument\n# (this interesting if the function is to be called repeatedly).\nplan=Planner(plan_exhaustive, 10.0, wl, eltype(X[1])) # wait 10s\nC=coherence(X, sr, wl; planner=plan)\n\n# how faster is this?\nusing BenchmarkTools\n@benchmark(coherence(X, sr, wl))\n@benchmark(coherence(X, sr, wl; planner=plan))\n...\n...\n\n\n\n\n\n(5)\nfunction coherence(ùêô‚ÇÅ     :: TFAnalyticSignalVector,\n                   ùêô‚ÇÇ     :: TFAnalyticSignalVector,\n                   frange :: fInterval,\n                   trange :: tInterval;\n              nonlinear :: Bool     = false,\n              allkinds  :: Bool     = false,\n              mode      :: Function = extract,\n              func      :: Function = identity,\n              w         :: Vector   = [],\n              check     :: Bool     = true)\n\n(6)\nfunction coherence(ùê±‚ÇÅ        :: Vector{Vector{T}},\n                   ùê±‚ÇÇ        :: Vector{Vector{T}},\n                   sr        :: Int,\n                   wl        :: Int,\n                   frange    :: fInterval,\n                   trange    :: tInterval,\n                   bandwidth :: IntOrReal = 2;\n              nonlinear  :: Bool         = false,\n              allkinds   :: Bool         = false,\n              mode       :: Function     = extract,\n              func       :: Function     = identity,\n              w          :: Vector       = [],\n              filtkind   :: FilterDesign = Butterworth(2),\n              fmin       :: IntOrReal    = bandwidth,\n              fmax       :: IntOrReal    = sr√∑2,\n              fsmoothing :: Smoother     = noSmoother,\n              tsmoothing :: Smoother     = noSmoother,\n              planner    :: Planner      = getplanner,\n              ‚è©        :: Bool         = true) where T<:Real\n\n\nalias: coh\n\nIf optional keyword parameter nonlinear is false (default), estimate linear (weighted) coherence measure, otherwise estimate the the (weighted) phase concentration measure.\n\nIf optional keyword argument allkinds is true all five kinds of coherence are returned. In this case the output is a 5-tuple of Coherence matrices, in the order:\n\ntotal coherence,\nreal coherence,\ninstantaneous coherence\nimaginary coherence,\nlagged coherence.\n\nIf allkinds is false (default) only the total (classical) coherence is returned as a single Coherence matrix.\n\n(5) The desired measure is obtained averaging across the TFAnalyticSignal objects in ùêô. Since this method uses pre-computed analytic signal objects, their .nonlinear field must agree with the nonlinear argument passed to this function.\n\nfrange, trange, w, mode and func have the same meaning as in the meanAmplitude function, however keep in mind that the two possible mode functions, i.e., extract and mean, in this function operate on complex numbers.\n\nThe checks performed in the meanAmplitude function are performed here too. In addition, if check is true, also check that\n\nif nonlinear is true, all objects in ùêô are nonlinear;\nif nonlinear is false, all objects in ùêô are linear.\n\nIf either check fails, print an error message and return Nothing.\n\n(6) Estimate the analytic signal of all data vectors in ùê± calling the TFanalyticsignal constructor and then use method (5) to obtained the desired measure.\n\nfrange, trange, mode, func, w and check have the same meaning as in the meanAmplitude function. The other arguments are passed to the TFanalyticsignal constructor, to which the reader is referred for understanding their action.\n\nSee also: meanAmplitude, meanDirection, timefrequencybi.jl.\n\nExamples: see the examples of comodulation function.\n\n\n\n\n\n","category":"function"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"References:","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"M. Congedo (2018), Non-Parametric Synchronization Measures used in EEG and MEG, Technical Report. GIPSA-lab, CNRS, University Grenoble Alpes, Grenoble INP.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"G. Nolte et al. (2004), Identifying true brain interaction from EEG data using the imaginary part of coherency. Clin Neurophysiol, 115(10), 2292-307.","category":"page"},{"location":"coherence/","page":"Coherence Matrices","title":"Coherence Matrices","text":"R. Pascual-Marqui (2007), Instantaneous and lagged measurements of linear and nonlinear dependence between groups of multivariate time series: frequency decomposition, arXiv:0711.1455.","category":"page"},{"location":"goertzel/#goertzel.jl","page":"Goertzel's Algorithms","title":"goertzel.jl","text":"","category":"section"},{"location":"goertzel/","page":"Goertzel's Algorithms","title":"Goertzel's Algorithms","text":"This unit implements three Goertzel's algorithms for estimating DFT complex coefficients at a specific frequency.","category":"page"},{"location":"goertzel/","page":"Goertzel's Algorithms","title":"Goertzel's Algorithms","text":"The result of Goertzel's algorithm for a given frequency is practically identical to the output of an FFT for that frequency, but requieres only t operations, where t is the window length in samples. Since the complexity of FFT algirthms is t*log(t), Goertzels' algorithm are advantageous when only one or a few coefficients are needed. Furthermore, the estimation of Goertzel's algorithms is not restricted to a Fourier discrete frequency, but can be in the whole positive real line up to the Nyquist frequency. Smart block on-line implementations are also possible.","category":"page"},{"location":"goertzel/","page":"Goertzel's Algorithms","title":"Goertzel's Algorithms","text":"References","category":"page"},{"location":"goertzel/","page":"Goertzel's Algorithms","title":"Goertzel's Algorithms","text":"Goertzel G (1958) An algorithm for the evaluation of finite trigonometric series. The American Mathematical Monthly, 65(1), 34-35.","category":"page"},{"location":"goertzel/","page":"Goertzel's Algorithms","title":"Goertzel's Algorithms","text":"See also here.","category":"page"},{"location":"goertzel/","page":"Goertzel's Algorithms","title":"Goertzel's Algorithms","text":"goertzel\ngoertzel_fast\ngoertzel2","category":"page"},{"location":"goertzel/#FourierAnalysis.goertzel","page":"Goertzel's Algorithms","title":"FourierAnalysis.goertzel","text":"function goertzel( x   :: Vector{T},\n                   f   :: IntOrReal,\n                   sr  :: Int,\n                   wl  :: Int,\n               startAT :: Int = 1) where T<:Union{Real, Complex}\n\nGiven a time series as input vector x sampled at sr sampling rate, return the DFT complex coefficient at the discrete Fourier frequency which is the closest to f. The coefficient is computed for the time window starting at startAt (one-based) and of lenght wl.\n\nIf startAT=1 (default) the first wl samples of the vector are considered.\n\nwl does not need to be power of 2.\n\nSee also: goertzel_fast, goertzel2.\n\nExamples:\n\nusing FourierAnalysis\nsr, t, f, a = 128, 128, 5, 10\nv=sinusoidal(a, f, sr, t, 0)\nc=goertzel(v, f, sr, t) # should output 0+aim\n\n\n\n\n\n","category":"function"},{"location":"goertzel/#FourierAnalysis.goertzel_fast","page":"Goertzel's Algorithms","title":"FourierAnalysis.goertzel_fast","text":"function goertzel_fast( x  :: Vector{T},\n                        wl :: Int,\n                        a  :: Real,\n                        c  :: Real,\n                        s  :: Real,\n                        d  :: Real,\n                    startAT:: Int = 1) where T<:Union{Real, Complex}\n\nFast version of the goertzel function to be preferred if the function is invoked repeatedly and speed is of concern. The user provides as arguments:\n\na time series as input vector x,\nwl, the number of samples in x (or the window length),\na = 2wl,\nc = cos(p) where p=2*œÄ*round(UInt16, (f*wl)/sr)/wl, f is the desired frequency and sr the sampling rate,\ns = sin(p)\nd = 2*c\nstartAt as in the goertzel function.\n\nSee also: goertzel, goertzel2.\n\n\n\n\n\n","category":"function"},{"location":"goertzel/#FourierAnalysis.goertzel2","page":"Goertzel's Algorithms","title":"FourierAnalysis.goertzel2","text":"function goertzel2( x  :: Vector{T},\n                    f  :: IntOrReal,\n                    sr :: Int,\n                    wl :: Int,\n                startAT:: Int = 1) where T<:Union{Real, Complex}\n\nLike the goertzel function, but allows estimating the DFT coefficient in the whole positive real line up to the Nyquist frequency. This is useful when the DFT coefficient is sought for a frequency which is not a discrete Fourier Frequency.\n\nUsing an appropriate taper this function allows almost exact recovery of both amplitude and phase at all frequencies in case of one sinusoid, whereas the goertzel function can do so only at exact Fourier discrete frequencies.\n\nSee also: goertzel_fast, goertzel.\n\nExamples:\n\nusing FourierAnalysis\nsr, t, f, a = 128, 128, 5, 10\nftrue=f+0.15\nv=sinusoidal(a, ftrue, sr, t, 0 )\nc=goertzel(v, f, sr, t) # should be 0+aim, but clearly fails\nd=goertzel2(v, ftrue, sr, t) # this get closer\n\n\n\n\n\n","category":"function"},{"location":"filters/#filters.jl","page":"Filter Banks","title":"filters.jl","text":"","category":"section"},{"location":"filters/","page":"Filter Banks","title":"Filter Banks","text":"This unit implements banks of band-pass filters interfacing the DSP.jl package. Those banks are used to create time-frequency analytic signal representations via the Hilbert transform.","category":"page"},{"location":"filters/","page":"Filter Banks","title":"Filter Banks","text":"At the bottom of this page you can find notes on DSP package useful functions.","category":"page"},{"location":"filters/#FilterDesign","page":"Filter Banks","title":"FilterDesign","text":"","category":"section"},{"location":"filters/","page":"Filter Banks","title":"Filter Banks","text":"FilterDesign = Union{ZeroPoleGain, FIRWindow}","category":"page"},{"location":"filters/","page":"Filter Banks","title":"Filter Banks","text":"Those are possible filter designs implemented in the DSP package. For design methods see the  DSP documentation.","category":"page"},{"location":"filters/","page":"Filter Banks","title":"Filter Banks","text":"filterbank","category":"page"},{"location":"filters/#FourierAnalysis.filterbank","page":"Filter Banks","title":"FourierAnalysis.filterbank","text":"function filterbank(x         :: Vector{T},\n                    sr        :: Int,\n                    bandwidth :: IntOrReal    = 2;\n                filtkind      :: FilterDesign = Butterworth(2),\n                fmin          :: IntOrReal    = bandwidth,\n                fmax          :: IntOrReal    = sr√∑2,\n                ‚è©           :: Bool         = true) where T<:Real\n\nPass signal vector x throught a bank of band-pass filters, given sampling rate sr and bandwidth parameter.\n\nThe kind of filters is specified by optional keyword argument filtkind, of type FilterDesign, using the DSP package. By default filtkind is a forward-backward (linear phase response) Butterworth IIR filter of order 2 in each direction (hence, 4th order total). See notes on DSP package useful functions for tips on how to design other IIR and FIR filters.\n\nReturn 2-tuple (f, Y), where f is a vector holding the center frequencies of the filter bank band-pass regions and Y a matrix holding in the i^th column the signal x band-pass iltered by the i^th band-pass filter. Hence, size(Y, 1)=length(x) and size(Y, 2)=length(f).\n\nThe filter bank is designed by means of argument bandwidth and optional keyword arguments fmin and fmax. These three arguments can be passed either as integers or real numbers. All band-pass regions have bandwidth equal to the bandwidth argument and overlap with adjacent band-pass regions. By default the lower limit of the first band-pass region is set at bandwidth Hz, and successive band-pass regions are defined up to, but excluding, the Nyquist frequency (sr2). If fmin is specified (in Hz), the center frequency of the first band-pass region is set as close as possible, but not below, fmin. If fmax is specified (in Hz), the center frequency of the last band-pass region is set as close as possible, but not above, fmax.\n\nHere are some examples of filter bank definitions given different arguments (sr=16 in all examples).\n\nbandwidth fmin fmax center frequencies band-pass regions\n4 - - 4 2-6\n2 - - 2, 3, 4, 5, 6 1-3, 2-4, 3-5, 4-6, 5-7\n2 3 7 3, 4, 5, 6 2-4, 3-5, 4-6, 5-7\n1 3 5 3, 3.5, 4, 4.5, 5 2.5-3.5, 3-4, 3.5-4.5, 4-5, 4.5-5.5\n1.1 3 5 2.75, 3.3, 3.85, 4.4, 4.95 2.2-3.3, 2.75-8.85, 3.3-4.4, 3.85-4.95, 4.4-5.5\n1.9 3 5 2.85, 3.8, 4.75 1.9-3.8, 2.85-4.75, 3.8-5.7\n\nnote: Nota Bene\nAt least sr samples should be trimmed at the beginning and end of the output signal Y, as those samples are severely distorted by the filtering process.If keyword optional argument ‚è© is true (default), the filtering is multi-threaded across band-pass filters. See Threads.\n\nThis function is called by the following functions operating on time-frequency reprsentations: TFanalyticsignal, TFamplitude, TFphase, meanAmplitude, concentration, meanDirection, comodulation, coherence.\n\nExamples:\n\nusing FourierAnalysis, DSP, Plots\n# generate a sinusoidal + noise\nf, sr, t = 8, 128, 512\nv=sinusoidal(1., f, sr, t, 0)\nx=v+randn(t)\nflabels, Y=filterbank(x, 128)\nflabels, Y=filterbank(x, 128; fmin=4, fmax=32)\nflabels, Y=filterbank(x, 128, 4; fmin=4, fmax=32)\nflabels, Y=filterbank(x, 128, 4;\n                      filtkind=Chebyshev2(8, 10),\n                      fmin=4,\n                      fmax=16)\n# trick for plotting the signal filtered in the band-pass regions\nfor i=1:size(Y, 2) Y[:, i].+=convert(eltype(Y), i)*1.5 end\nmylabels=Array{String}(undef, 1, length(flabels))\nfor i=1:length(flabels) mylabels[1, i]=string(flabels[i])*\" Hz\" end\nplot(Y; c=:grey, labels=mylabels)\n\n\n\n\n\n","category":"function"},{"location":"filters/#notes-on-DSP-package-useful-functions","page":"Filter Banks","title":"notes on DSP package useful functions","text":"","category":"section"},{"location":"filters/","page":"Filter Banks","title":"Filter Banks","text":"using DSP, Plots\n\n### create a time-series with dominant frequency at 10Hz\nf, sr, t = 10, 128, 512\nv=sinusoidal(1., f, sr, t, 0)+randn(512)\nplot(v)\n\n### IIR filters\nfilterBP = digitalfilter(Bandpass(8/(sr/2), 12/(sr/2)), Chebyshev2(8, 10))\nfilterLP = digitalfilter(Lowpass(13/(sr/2)), Butterworth(4))\nfilterHP = digitalfilter(Highpass(7/(sr/2)), Butterworth(4))\n# forward filter, unlinear phase response\nz=filt(filterBP, v)\nplot([v, z])\n# forward-backward filter, linear phase response\nz=filtfilt(filterBP, v)\nplot([v, z])\n\n### FIR filters\nresponsetype = Bandpass(8, 12; fs=sr)\nfiltkind = FIRWindow(hanning(64))\nfilterBP = digitalfilter(responsetype, filtkind)\n# forward filter, unlinear phase response\nz=filt(digitalfilter(responsetype, filtkind), v)\nplot([v, z])\n# forward-backward filter, linear phase response\nz=filtfilt(digitalfilter(responsetype, filtkind), v)\nplot([v, z])\n\n### resampling\nz1=resample(x, 0.5)   # downsample by 2\nz2=resample(x, 2)     # upsample by 2\nplot([x, z1, z2])\n\n### estimate peak frequency using ESPRIT algorithm\npeakv=esprit(v, 200, 2, sr)[1]\n# this may fails.\n# If the approximate location of the peak is sought,\nfirst band-pass filter the data\nfilter = digitalfilter(Bandpass(7/(sr/2), 13/(sr/2)), Chebyshev2(8, 10))\nz = filtfilt(filter, v)\npeakz=esprit(z, 200, 2, sr)[1]\n\n### mean power frequency\nmeanfreq(v, t)\n\n### root mean square\nrms(v)\n\n### cross-correlation\ny=sinusoidal(1., f, sr, t, 0)+randn(512)\nplot(xcorr(v, y))\n\n### convolution (using the FFT algorithm)\nplot(conv(v, y))\n\n### closest product of 2, 3, 5, and 7 greater than or equal to n.\n# This is used to find a window length for which FFTW will be able\n# to find an efficient FFT plan\nnextfastfft(1031)\n\n### estimate the delay by locating the peak of the cross-correlation.\n# The output delay will be positive when v is delayed with respect y,\n# negative if advanced, 0 otherwise.\nfinddelay(v, y)\nfinddelay([0, 0, 1, 2, 3], [1, 2, 3]) # return 2\nfinddelay([1, 2, 3], [0, 0, 1, 2, 3]) # return -2\n\n### shift elements of signal v in time by a given amount s of samples\n### and fill the spaces with zeros.\n# For circular shifting, use circshift.\nshiftsignal([1, 2, 3], 2)  # return [0, 0, 1]\nshiftsignal([1, 2, 3], -2) # return [3, 0, 0]\n\n### use finddelay() and shiftsignal() to time align v to y.\n# Also return the delay of v with respect to y.\nalignsignals([0, 0, 1, 2, 3], [1, 2, 3]) # return ([1, 2, 3, 0, 0], 2)\nalignsignals([1, 2, 3], [0, 0, 1, 2, 3]) # return ([0, 0, 1], -2)","category":"page"},{"location":"timefrequency/#timefrequency.jl","page":"TF Representations","title":"timefrequency.jl","text":"","category":"section"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"This unit implements time-frequency representations based on analytic signal estimations. It uses the filters.jl unit for filtering the signals in a filter bank and the hilbert.jl unit for computing the Hilbert transform.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"The main object in the time-frequency domain is the TFAnalyticSignal, from which the TFAmplitude and TFPhase objects are derived. Taken together these three objects are referred to as TFobjects and vectors of them are a TFobjectsVector type.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Object Vector type Constructors from data\nTFAnalyticSignal TFAnalyticSignalVector TFanalyticsignal\nTFAmplitude TFAmplitudeVector TFamplitude\nTFPhase TFPhaseVector TFphase","category":"page"},{"location":"timefrequency/#TFAnalyticSignal","page":"TF Representations","title":"TFAnalyticSignal","text":"","category":"section"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Categories: data objects, TFobjects.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"An analytic signal object has the following structure:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"struct TFAnalyticSignal\n    y          :: Matrix{T} where T<:Complex\n    bandwidth  :: IntOrReal\n    flabels    :: Vector{S} where S<:Real\n    nonlinear  :: Bool\n    fsmoothing :: Smoother\n    tsmoothing :: Smoother\nend","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Fields:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"y: a complex matrix holding the analytic signal in the time-frequency domain, with frequency band-pass regions (in Hz) in rows and time (samples) in columns.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"bandwidth: the bandwidth (in Hz) of the filter bank band-pass regions. See constructor TFanalyticsignal for details. It can be an integer or a real number.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"flabels: a vector holding all center frequencies (in Hz) of the filter bank band-pass regions. Those are the frequency labels for the rows of y.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"non-linear: a flag indicating whether the analytic signal has been normalized so as to have amplitude10 at all points. Such normalization allows non-linear univariate and bivariate estimations (see timefrequencyuni.jl and timefrequencybi.jl).","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"fsmoothing: a flag of the Smoother type indicating whether the analytic signal has been smoothed across adjacent frequency band-pass regions. If no frequency smoothing has been applied, it is equal to noSmoother, which is the default in all constructors.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"tsmoothing: a flag of the Smoother type indicating whether the analytic signal has been smoothed across adjacent samples (time). If no time smoothing has been applied, it is equal to noSmoother, which is the default in all constructors.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Note: In Julia the fields are accessed by the usual dot notation, e.g., you may verify that for TFAnalyticSignal object Y,","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"length(Y.flabels) == dim(Y.z, 1)","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"A vector of TFAnalyticSignal objects is of type TFAnalyticSignalVector.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Methods for TFAnalyticSignal and TFAnalyticSignalVector objects","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"method TFAnalyticSignal TFAnalyticSignalVector\namplitude ‚úî ‚úî\nphase ‚úî ‚úî\npolar ‚úî \nextract ‚úî ‚úî\nmean ‚úî ‚úî\nsmooth ‚úî ‚úî\nsameParams  ‚úî\nisLinear  ‚úî\nisNonLinear  ‚úî\nmeanAmplitude  ‚úî\nconcentration  ‚úî\ncomodulation  ‚úî\nmeanDirection  ‚úî\ncoherence  ‚úî","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Generic Constructors:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"In order to construct a TFAnalyticSignal object from univariate data, FourierAnalysis provides two TFanalyticsignal constuctors, which is what you will use in practice most of the time.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Manual constructors are also possible, for which you have to provide appropriate arguments. The default manual constructor of TFAnalyticSignal objects is","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"TFAnalyticSignal(y, bandwidth, flabels, nonlinear, fsmoothing, tsmoothing).","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"No other generic constructor is provided for this object.","category":"page"},{"location":"timefrequency/#TFAmplitude","page":"TF Representations","title":"TFAmplitude","text":"","category":"section"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Categories: data objects, TFobjects.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"An amplitude object has the following structure:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"struct TFAmplitude\n    y          :: Matrix{T} where T<:Real\n    bandwidth  :: IntOrReal\n    flabels    :: Vector{S} where S<:Real\n    fsmoothing :: Smoother\n    tsmoothing :: Smoother\n    func       :: Function\nend","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Fields:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"y: a real matrix holding the amplitude (modulus) of an analytic signal in the time-frequency domain, often referred to as the envelope, with frequency band-pass regions (in Hz) in rows and time (samples) in columns.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"bandwidth: the bandwidth (in Hz) of the filter bank band-pass regions. See constructor TFanalyticsignal for details. It can be an integer or a real number.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"flabels: a vector holding all center frequencies (in Hz) of the filter bank band-pass regions. Those are the frequency labels for the rows of y.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"fsmoothing: a flag of the Smoother type indicating whether the amplitude has been smoothed across adjacent frequency band-pass regions. If no frequency smoothing has been applied, it is equal to noSmoother, which is the default in all constructors.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"tsmoothing: a flag of the Smoother type indicating whether the amplitude has been smoothed across adjacent samples (time). If no time smoothing has been applied, it is equal to noSmoother, which is the default in all constructors.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Note: Smoothing flags in this object indicate that the amplitude has been smoothed, whereas in the TFAnalyticSignal object indicate that the analytic signal has been smoothed. Note that it is not equivalent to obtain amplitude from smoothed analytic signal (e.g., using the amplitude function) or to smooth the amplitude of analytic signal, e.g., using the TFamplitude constructor.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"func: a name of a function that has been applied element-wise to the matrix .y holding the amplitude. All constructors from data by default use the identity (do nothing) function.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"A vector of TFAmplitude objects is of type TFAmplitudeVector.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Methods for TFAmplitude and TFAmplitudeVector objects","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"method TFAmplitude TFAmplitudeVector\nextract ‚úî ‚úî\nmean ‚úî ‚úî\nsmooth ‚úî ‚úî\nsameParams  ‚úî\nisLinear  ‚úî\nisNonLinear  ‚úî\nmeanAmplitude  ‚úî\ncomodulation  ‚úî","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Generic Constructors:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"In order to construct a TFAmplitude object from univariate data, FourierAnalysis provides four TFamplitude constuctors, which is what you will use in practice most of the time.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Manual constructors are also possible, for which you have to provide appropriate arguments. The default manual constructor of TFAmplitude objects is","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"TFAmplitude(y, bandwidth, flabels, fsmoothing, tsmoothing, func).","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Other generic constructors are also provided:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"TFAmplitude(y, bandwidth, flabels, fsmoothing, tsmoothing)","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"enables construction giving only y, bandwidth, flabels, fsmoothing and tsmoothing. func is set automatically to identity;","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"TFAmplitude(y, bandwidth, flabels)","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"acts like the constructor above, but sets by default also both fsmoothing and tsmoothing to noSmoother.","category":"page"},{"location":"timefrequency/#TFPhase","page":"TF Representations","title":"TFPhase","text":"","category":"section"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Categories: data objects, TFobjects.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"A phase object has the following structure:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"struct TFPhase\n    y          :: Matrix{T} where T<:Real\n    bandwidth  :: IntOrReal\n    flabels    :: Vector{S} where S<:Real\n    nonlinear  :: Bool\n    fsmoothing :: Smoother\n    tsmoothing :: Smoother\n    unwrapped  :: Bool\n    func       :: Function\nend","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Fields:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"y: a real matrix holding the phase (argument) of an analytic signal in the time-frequency domain, with frequency band-pass regions (in Hz) in rows and time (samples) in columns. By default the phase is represented in œÄ œÄ.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"bandwidth: the bandwidth (in Hz) of the filter bank band-pass regions. See constructor TFanalyticsignal for details. It can be an integer or a real number.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"flabels: a vector holding all center frequencies (in Hz) of the filter bank band-pass regions. Those are the frequency labels for the rows of y.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"non-linear: a flag indicating whether the phase has been estimated from analytic signal normalized so as to have amplitude10 at all points. Such normalization allows non-linear univariate and bivariate estimations (see timefrequencyuni.jl and timefrequencybi.jl).","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"fsmoothing: a flag of Smoother indicating whether the phase has been smoothed across adjacent frequency band-pass regions. If no frequency smoothing has been applied, it is equal to noSmoother, which is the default in all constructors.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"tsmoothing: a flag of the Smoother type indicating whether the phase has been smoothed across adjacent samples (time). If no time smoothing has been applied, it is equal to noSmoother, which is the default in all constructors.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Note: Smoothing raw phase estimates is unappropriate since the phase is a discontinous function, however it makes sense to smooth phase if the phase is unwrapped (see below).","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Note: Smoothing flags in this object indicate that the (unwrapped) phase has been smoothed, whereas in the TFAnalyticSignal object indicate that the analytic signal has been smoothed. Note that it is not equivalent to obtain unwrapped phase from smoothed analytic signal (e.g., using the phase function) or to smooth the unwrapped phase of analytic signal, e.g., using the TFphase constructor.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"unwrapped: a flag indicating if the phase has been unwrapped. The unwrapped phase is defined as the cumulative sum of the phase along the time dimension once the phase is represented in 0 2œÄ.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"func: a name of a function that has been applied element-wise to the matrix .y holding the phase. All constructors from data by default use the identity (do nothing) function. Examples of possible functions:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"func=x->x+œÄ return the phase in [0, 2œÄ],\nfunc=x->x/œÄ return the phase in [-1, 1],\nfunc=sin return the sine of the phase.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"A vector of TFPhase objects is of type TFPhaseVector.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Methods for TFPhase and TFPhaseVector objects","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"method TFAmplitude TFAmplitudeVector\nunwrapPhase ‚úî ‚úî\nisUnwrapped ‚úî ‚úî\nextract ‚úî ‚úî\nmean ‚úî ‚úî\nsmooth ‚úî ‚úî\nsameParams  ‚úî\nisLinear  ‚úî\nisNonLinear  ‚úî","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Generic Constructors:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"In order to construct a TFPhase object from univariate data, FourierAnalysis provides four TFphase constuctors, which is what you will use in practice most of the time.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Manual constructors are also possible, for which you have to provide appropriate arguments. The default manual constructor of TFPhase objects is","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"TFPhase(y, bandwidth, flabels, nonlinear,\n        fsmoothing, tsmoothing, unwrapped, func).","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Other generic constructors are also provided:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"TFPhase(y, bandwidth, flabels, nonlinear, fsmoothing, tsmoothing)","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"enables construction giving only y, bandwidth, flabels, fsmoothing and tsmoothing. unwrapped is set to false and func is set to identity;","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"TFPhase(y, bandwidth, flabels)","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"acts like the constructor above, but sets by default also nonlinear to true and both fsmoothing and tsmoothing to noSmoother.","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"Constructors from data:","category":"page"},{"location":"timefrequency/","page":"TF Representations","title":"TF Representations","text":"TFanalyticsignal\nTFamplitude\nTFphase","category":"page"},{"location":"timefrequency/#FourierAnalysis.TFanalyticsignal","page":"TF Representations","title":"FourierAnalysis.TFanalyticsignal","text":"(1)\nfunction TFanalyticsignal(x         :: Vector{T},\n                          sr        :: Int,\n                          wl        :: Int          = 0,\n                          bandwidth :: IntOrReal    = 2;\n                      fmin          :: IntOrReal    = bandwidth,\n                      fmax          :: IntOrReal    = sr√∑2,\n                      filtkind      :: FilterDesign = Butterworth(2),\n                      nonlinear     :: Bool         = false,\n                      fsmoothing    :: Smoother     = noSmoother,\n                      tsmoothing    :: Smoother     = noSmoother,\n                      planner       :: Planner      = getplanner,\n                      ‚è©           :: Bool         = true) where T<:Real\n\n(2)\nfunction TFanalyticsignal(ùê±         :: Vector{Vector{T}},\n                      <same arguments as method (1)>\n\n\n(1)\n\nGiven sampling rate sr, construct a TFAnalyticSignal object from univariate data x, that is, a time-frequency representation of real vector x.\n\nCall three functions in series performing the three following operations:\n\ni. pass the data throught a bank of pass-band filters calling function filterbank,\n\nii. compute the analytic signal calling function analyticsignal (method (1) therein),\n\niii. If requested, smooth the analytic signal along the time and/or frequency dimension calling function smooth.\n\nThe arguments passed to each of these functions are:\n\nfilterbank analyticsignal smooth\nx wl fsmoothing\nsr nonlinear tsmoothing\nbandwidth planner \nfiltkind ‚è© \nfmin  \nfmax  \n‚è©  \n\nRefer to the documentation of each function to learn the meaning of each argument.\n\nBy default the wl argument is set to length(x).\n\nIf ‚è© is true (default), filtering and computation fo the analytic signal are multi-threaded across band-pass regions as long as the number of the regions is at least twice the number of threads Julia is instructed to use. See Threads.\n\n(2)\n\nGiven sampling rate sr, construct a TFAnalyticSignalVector object from a vector of univariate data ùê±, that is, from the time-frequency representations of the vectors in ùê±.\n\nThis method operates as method (1) with the following exceptions:\n\nBy default the wl argument is set to length(x) for each vectors in ùê±. If another values is given, it will be used for all of them.\n\nIf ‚è© is true (default), the method is run in multi-threaded mode across the vectors in ùê± as long as their number is at least twice the number of threads Julia is instructed to use, otherwise this method attempts to run each analytic signal estimation in multi-threaded mode like in method (1). See Threads.\n\nIf a Planner is not explicitly passed as an argument, the FFTW plan is computed once and applied for all analytic signal estimations.\n\nSee: filterbank, analyticsignal, smooth.\n\nExamples:\n\nusing Plots, FourierAnalysis\n\n# generate some data\nsr, t, bandwidth=128, 512, 2\nh=taper(harris4, t)\nx1=sinusoidal(10, 8, sr, t, 0)\nx2=sinusoidal(10, 19, sr, t, 0)\nx=Vector((x1+x2).*h.y+randn(t))\ny1=sinusoidal(10, 6, sr, t, 0)\ny2=sinusoidal(10, 16, sr, t, 0)\ny=Vector((y1+y2).*h.y+randn(t))\nplot([x, y])\n\n# TFAnalyticSignal object for x (method (1))\nY = TFanalyticsignal(x, sr, sr*4; fmax=32)\n\n# vector of TFAnalyticSignal objects for x and y (method (2))\nùíÄ = TFanalyticsignal([x, y], sr, sr*4; fmax=32)\n\n# (for shortening comments: TF=time-frequency, AS=analytic signal)\n\n# mean AS in a TF region (8:12Hz and samples 1:128) for the first object\nm=mean(ùíÄ[1], (8, 12), (1, 128)) # Output a complex number\n\n# extract the AS in a TF region (8:12Hz and samples 1:128) for the first object\nE=extract(ùíÄ[1], (8, 12), (1, 128)) # Output a complex matrix\n\n# mean AS in a TF region (8:12Hz and samples 1:128) for the two objects\nùê¶=mean(ùíÄ, (8, 12), (1, 128)) # Output a vector of complex numbers\n# same computation without checking homogeneity of the two objects in ùíÄ (faster)\nùê¶=mean(ùíÄ, (8, 12), (1, 128); check=false)\n\n# extract the AS in a TF region (8:12Hz and samples 1:128) for the two objects\nùêÑ=extract(ùíÄ, (8, 12), (8, 12)) # Output a vector of complex matrices\n\n# plot the real part of the AS of x (see unit recipes.jl)\n\n# gather first useful attributes for the plot\nusing Plots.Measures\ntfArgs=(right_margin = 2mm,\n        top_margin = 2mm,\n        xtickfont = font(10, \"Times\"),\n        ytickfont = font(10, \"Times\"))\n\nheatmap(tfAxes(Y)..., real(Y.y);\n        c=:pu_or, tfArgs...)\n\n# ...the imaginary part\nheatmap(tfAxes(Y)..., imag(Y.y);\n        c=:bluesreds, tfArgs...)\n\n# ...the amplitude\nheatmap(tfAxes(Y)..., amplitude(Y.y);\n        c=:amp, tfArgs...)\n\n# ...the amplitude of the AS smoothed in frequency and time\nheatmap(tfAxes(Y)..., amplitude(smooth(hannSmoother, hannSmoother, Y).y);\n        c=:fire, tfArgs...)\n\n# ...the phase\nheatmap(tfAxes(Y)..., phase(Y.y);\n        c=:bluesreds, tfArgs...)\n\n# or generate a TFAmplitude object from the AS\nA=TFamplitude(Y)\n# and plot it (with different colors)\nheatmap(tfAxes(A)..., A.y;\n        c=:fire, tfArgs...)\n\n# generate a TFPhase object\nœ¥=TFphase(Y)\n# and plot it (with custom colors)\nheatmap(tfAxes(œ¥)..., œ¥.y;\n        c=:pu_or, tfArgs...)\n\n# compute and plot phase in [0, 2œÄ]\nheatmap(tfAxes(Y)..., TFphase(Y; func=x->x+œÄ).y;\n        c=:amp, tfArgs...)\n\n# compute and plot unwrapped phase\nheatmap(tfAxes(Y)..., TFphase(Y; unwrapped=true).y;\n        c=:amp, tfArgs...)\n\n# smooth time-frequency AS: smooth frequency\nZ=smooth(blackmanSmoother, noSmoother, Y)\n\n# plot amplitude of smoothed analytic signal\nheatmap(tfAxes(Z)..., amplitude(Z.y);\n        c=:amp, tfArgs...)\n\n# not equivalently (!), create an amplitude object and smooth it:\n# in this case the amplitude is smoothed, not the AS\nA=smooth(blackmanSmoother, noSmoother, TFamplitude(Y))\nheatmap(tfAxes(A)..., A.y;\n        c=:fire, tfArgs...)\n\n# Smoothing raw phase estimates is unappropriate\n# since the phase is a discontinous function, however it makes sense\n# to smooth phase if the phase is unwrapped.\nheatmap(tfAxes(Y)...,\n        smooth(blackmanSmoother, noSmoother, TFphase(Y; unwrapped=true)).y;\n        c=:amp, tfArgs...)\n\n# smooth AS: smooth both frequency and time\nE=smooth(blackmanSmoother, blackmanSmoother, Y)\n\n# plot amplitude of smoothed analytic signal\nheatmap(tfAxes(E)..., amplitude(E.y);\n        c=:fire, tfArgs...)\n\n# plot phase of smoothed analytic signal\nheatmap(tfAxes(E)..., phase(E.y);\n        c=:bluesreds, tfArgs...)\n\n# not equivalently (!), create amplitude and phase objects and smooth them\nA=smooth(blackmanSmoother, blackmanSmoother, TFamplitude(Y))\nheatmap(tfAxes(A)..., A.y;\n        c=:fire, tfArgs...)\n\nœ¥=smooth(blackmanSmoother, blackmanSmoother, TFphase(Y, unwrapped=true))\nheatmap(tfAxes(œ¥)..., œ¥.y;\n        c=:pu_or, tfArgs...)\n\n# smooth again\nœ¥=smooth(blackmanSmoother, blackmanSmoother, œ¥)\nheatmap(tfAxes(œ¥)..., œ¥.y;\n        c=:pu_or, tfArgs...)\n# and again ...\n\n# create directly smoothed AS\nY=TFanalyticsignal(x, sr, t, bandwidth;\n                   fmax=32,\n                   fsmoothing=hannSmoother,\n                   tsmoothing=hannSmoother)\n\n# plot amplitude of smoothed analytic signal\nheatmap(tfAxes(Y)..., amplitude(Y.y);\n        c=:amp, tfArgs...)\n\n# create directly smoothed Amplitude\nA=TFamplitude(x, sr, t, bandwidth;\n              fmax=32,\n              fsmoothing=hannSmoother,\n              tsmoothing=hannSmoother)\n\n# plot smoothed amplitude\nheatmap(tfAxes(A)..., A.y;\n        c=:amp, tfArgs...)\n\n# compute a TFAnalyticSignal object with non-linear AS\nY=TFanalyticsignal(x, sr, t, bandwidth; fmax=32, nonlinear=true)\n\n# check that it is non-linear\nY.nonlinear\n\n# check that the amplitude is now 1.0 everywhere\nnorm(amplitude(Y.y)-ones(eltype(Y.y), size(Y.y))) # must be zero\n\n# plot non-linear phase\nheatmap(tfAxes(Y)..., phase(Y.y);\n        c=:bkr, tfArgs...)\n\n# get the center frequencies of TFAmplitude object A\nA.flabels\n\n# extract the amplitude in a time-frequency region\nextract(A, (2, 10), (1, 256)) # output a real matrix\n\n# extract the amplitude in a time-frequency region at only one frequency\nextract(A, 10, (1, 256)) # output a row vector\n\n# extract the amplitude at one temporal sample at one frequency\nextract(A, 10, 12) # or extract(A, 10.0, 12)\n\n# extract amplitude at one temporal sample in a frequency region\nextract(A, (10, 12), 12) # or extract(A, (10.0, 12.0), 12)\n\n# extract amplitude at one temporal sample and all frequencies\nextract(A, :, 12) # output a (column) vector\n\n# compute the mean in a time-frequency region:\nmean(A, (2, 10), (1, 256)) # output a real number\n# is equivalent to (but may be less efficient than)\nmean(extract(A, (2, 10), (1, 256)))\n\n# using column sign for extracting all time samples\nextract(A, (2, 10), :)\n\n# This:\nextract(A, :, :)\n# is equivalent to this:\nA.y\n# but if you don't need to extract all frequencies,\n# use the extract function to control what frequencies will be extracted:\n# This\nextract(A, (4, 5), 10)\n# is not equivalent to this\nA.y[4:5, 10]\n# since the `extract` function finds the correct rows corresponding\n# to the sought frequencies (in Hz), while A.y[4:5, 10]\n# just returns the elements [4:5, 10] in the TF amplitude object\n\n# Although the first center frequency in A is 2Hz, its\n# band-pass region is 1-3Hz, therefore the frequency range 1:10 is accepted\nmean(A, (1, 10), (1, 256))\n# but this result in an error (see the REPL) since 0.5 is out of range:\nmean(A, (0.5, 10), (1, 256))\n\n# using a colon sign for time range\na=mean(A, (1, 10), :)\n# using an integer for time range (indicates one specific sample)\na=mean(A, (1, 10), 16)\n\n# using a colon sign for frequency range\na=mean(A, :, (1, 16))\n# using a real number for frequency range\na=mean(A, 8.5, (1, 16))\n\n# NB: the `extract` and `mean` functions work with the same syntax\n#     for objects TFAnayticSignal, TFAmplitude and TFPhase.\n\n\n\n\n\n","category":"function"},{"location":"timefrequency/#FourierAnalysis.TFamplitude","page":"TF Representations","title":"FourierAnalysis.TFamplitude","text":"(1)\nfunction TFamplitude(Z::TFAnalyticSignal;\n                func::Function=identity)\n\n(2)\nfunction TFamplitude(ùêô::TFAnalyticSignalVector;\n                func::Function=identity)\n\n(3)\nfunction TFamplitude(x         :: Vector{T},\n                     sr        :: Int,\n                     wl        :: Int,\n                     bandwidth :: IntOrReal = 2;\n                func       :: Function     = identity,\n                filtkind   :: FilterDesign = Butterworth(2),\n                fmin       :: IntOrReal    = bandwidth,\n                fmax       :: IntOrReal    = sr√∑2,\n                fsmoothing :: Smoother     = noSmoother,\n                tsmoothing :: Smoother     = noSmoother,\n                planner    :: Planner      = getplanner,\n                ‚è©        :: Bool         = true) where T<:Real =\n\n(4)\nfunction TFamplitude(ùê± :: Vector{Vector{T}},\n                < same arguments as method (3) >\n\n(1)\n\nConstruct a TFAmplitude object computing the amplitude of TFAnalyticSignal object Z. Optional keyword argument func is a function to be applied element-wise to the data matrix of the output. By default, the identity (do nothing) function is applied.\n\n(2)\n\nConstruct a TFAmplitudeVector object from a TFAnalyticSignalVector object executing method (1) for all TFAnalyticSignal objects in ùêô\n\n(3)\n\nCall TFanalyticsignal to obtain the time-frequency analytic signal of real signal vector x and construct a TFAmplitude object holding the time-frequency amplitude (the mudulus, often referred to as the envelope) of x.\n\nAll arguments are used for regulating the estimation of the analytic signal, with the exception of func, fsmoothing and fsmoothing:\n\nfunc is an optional function to be applied to the amplitude data matrix output.\n\nIn order to estimate the analytic signal in the time-frequency domain this function calls the TFanalyticsignal constructor (method (1) therein), with both fsmoothing and tsmoothing arguments set to noSmoother. Arguments fsmoothing and fsmoothing are then used to smooth the amplitude.\n\nIn order to obtain amplitude estimations on smoothed analytic signal instead, create a TFAnalyticSignal object passing a Smoother to the TFanalyticsignal constructor and then use method (1) to obtain the amplitude. Such amplitude estimation can be further smoothed using the smooth function, as shown in the examples.\n\nFor the meaning of all other arguments, which are passed to function TFanalyticsignal, see the documentation therein.\n\n(4)\n\nConstruct a TFAmplitudeVector object from a vector of real signal vectors ùê±, executing method (3) for all of them. In order to estimate the time-frequency analytic signal for a vector of signals, method (2) of TFanalyticsignal is called.\n\nSee: TFanalyticsignal, TFAmplitude.\n\nSee also: amplitude.\n\nExamples: see the examples of TFanalyticsignal.\n\n\n\n\n\n","category":"function"},{"location":"timefrequency/#FourierAnalysis.TFphase","page":"TF Representations","title":"FourierAnalysis.TFphase","text":"(1)\nfunction TFphase(Z :: TFAnalyticSignal;\n            func      :: Function = identity,\n            unwrapped :: Bool     = false)\n\n(2)\nfunction TFphase(ùêô :: TFAnalyticSignalVector;\n            func      ::Function = identity,\n            unwrapped ::Bool     = false)\n\n(3)\nfunction TFphase(x         :: Vector{T},\n                 sr        :: Int,\n                 wl        :: Int,\n                 bandwidth :: IntOrReal = 2;\n           unwrapped  :: Bool         = false,\n           func       :: Function     = identity,\n           filtkind   :: FilterDesign = Butterworth(2),\n           fmin       :: IntOrReal    = bandwidth,\n           fmax       :: IntOrReal    = sr√∑2,\n           nonlinear  :: Bool         = false,\n           fsmoothing :: Smoother     = noSmoother,\n           tsmoothing :: Smoother     = noSmoother,\n           planner    :: Planner      = getplanner,\n           ‚è©        :: Bool         = true) where T<:Real\n\n(4)\nfunction TFphase(ùê± :: Vector{Vector{T}},\n                < same arguments as method (3) >\n\n(1)\n\nConstruct a TFPhase object computing the phase of TFAnalyticSignal object Z. By default the phase is represented in œÄ œÄ.\n\nIf optional keyword argument unwrapped is true (false by defalut), the phase is unwrapped, that is, it holds the cumulative sum of the phase along the time dimension once this is represented in 0 2œÄ.\n\nOptional keyword argument func is a function to be applied element-wise to the data matrix of the output. By default, the identity (do nothing) function is applied. If unwrapped is true, the function is applied on the unwrapped phase.\n\n(2)\n\nConstruct a TFPhaseVector object from a TFAnalyticSignalVector object executing method (1) for all TFAnalyticSignal objects in ùêô\n\n(3)\n\nCall TFanalyticsignal to obtain the time-frequency analytic signal of real signal vector x and construct a TFPhase object holding the time-frequency phase (argument) of x.\n\nAll arguments are used for regulating the estimation of the analytic signal, with the exception of unwrapped, func, fsmoothing and fsmoothing.\n\nunwrapped has the same meaning as in method (1) and (2).\n\nfunc is an optional function to be applied to the phase data matrix output. If unwrapped is true, it is applied to the unwrapped phase.\n\nIn order to estimate the analytic signal in the time-frequency domain this function calls the TFanalyticsignal constructor (method (1) therein), with both fsmoothing and tsmoothing arguments set to noSmoother. fsmoothing and fsmoothing are then used to smooth the phase if unwrapped is true.\n\nIn order to obtain phase estimations on smoothed analytic signal instead, create a TFAnalyticSignal object passing a Smoother to the TFanalyticsignal constructor and then use method (1) to obtain the phase.\n\nFor the meaning of all other arguments, which are passed to function TFanalyticsignal, see the documentation therein.\n\n(4)\n\nConstruct a TFPhaseVector object from a vector of real signal vectors ùê±, executing method (3) for all of them. In order to estimate the time-frequency analytic signal for a vector of signals, method (2) of TFanalyticsignal is called.\n\nSee: TFanalyticsignal, TFPhase.\n\nSee also: phase, unwrapPhase, polar.\n\nExamples: see the examples of TFanalyticsignal.\n\n\n\n\n\n","category":"function"},{"location":"tools/#tools.jl","page":"Tools","title":"tools.jl","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"This unit implements","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"functions that are useful when employing the FFT,\nspecific methods: they apply to Julia's types or to single objects created by FourierAnalysis,\ngeneric methods: they apply to entire categories of objects created by FourierAnalysis.","category":"page"},{"location":"tools/#functions","page":"Tools","title":"functions","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"function description\nsinusoidal generate a sinusoidal wave\nfres FFT frequency resolution\nf2b bin on a real-FFT vector best matching a frequency\nb2f frequency (in Hz) that correspond to a bin on a real-FFT vector\nfdf all Fourier discrete frequencies for a real-FFT\nbrange range of bins for a real-FFT vector covering all Fourier discrete frequencies\nbbands limits of all bandwidth-spaced band-pass regions of a real-FFT vectors, in bins\nfbands limits of all bandwidth-spaced band-pass regions of a real-FFT vectors, in frequencies (Hz)\ndecibel convert a measure or a ratio between two measures into deciBels","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"sinusoidal\nfres\nf2b\nb2f\nfdf\nbrange\nbbands\nfbands\ndecibel","category":"page"},{"location":"tools/#FourierAnalysis.sinusoidal","page":"Tools","title":"FourierAnalysis.sinusoidal","text":"function sinusoidal(a :: IntOrReal,\n                    f :: IntOrReal,\n                   sr :: Int,\n                    t :: Int,\n                    Œ∏ :: IntOrReal = 0.;\n                DClevel = 0.)\n\nGenerate a sinusoidal wave with peak amplitude a, frequency f, sampling rate sr, duration (in samples) t, angle Œ∏ (Œ∏=0 makes a sine, Œ∏=œÄ/2 makes a cosine) and optional keyword argument DC (float), the DC level defaulting to zero. It is adopted the convention that a sine wave starts at zero.\n\nExamples:\n\nusing FourierAnalysis, Plots\n\n# create and plot a sinusoidal wave of 128 samples with\n# peak amplitude 1, frequency 12Hz, sr=64, phase=œÄ/2\nv=sinusoidal(1., 12, 64, 128, œÄ/2)\nplot(v)\n\n# estimate amplitude of a sinusoidal wave using Goertzel algorithm\nf, sr, t = 32, 128, 128\nv=sinusoidal(3., f, sr, t, 0)\nc=goertzel(v, f, sr, t) # c should be equal to 0+3.0im\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.fres","page":"Tools","title":"FourierAnalysis.fres","text":"function fres(sr :: Int,\n              wl :: Int)\n\nFFT frequency resolution given sampling rate sr and window length wl.\n\nSee also: f2b, b2f, fdf, brange.\n\nExamples:\n\nusing FourierAnalysis\nfres(1024, 2048) # return 0.5\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.f2b","page":"Tools","title":"FourierAnalysis.f2b","text":"function f2b(f :: IntOrReal,\n            sr :: Int,\n            wl :: Int;\n        DC :: Bool = false)\n\nfrequency to bin. Return the bin (position) in a real-FFT vector best matching a frequency f (in Hz), given sampling rate sr and window length wl. The frequency can be given either as an integer or as a real number.\n\nIf the requested f is exactly in between two Fourier discrete frequencies, then the smallest of the two equidistant frequencies is returned.\n\nThe FFT vector is assumed to be 1-based (as always in Julia). If DC is false, the first discrete frequency is assumed to be at bin 1, otherwise the DC is assumed to be at bin 1 and the first discrete frequency at bin 2.\n\nIf DC is false return 0 for frequencies inferior to half the frequency resolution.\n\nSee also: fres, b2f, fdf, brange.\n\nExamples:\n\nusing FourierAnalysis\nf2b(10, 512, 1024) # return 20\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.b2f","page":"Tools","title":"FourierAnalysis.b2f","text":"function b2f(bin :: Int,\n              sr :: Int,\n              wl :: Int;\n        DC :: Bool = false)\n\nbin to frequency. Return the closest discrete Fourier frequency (in Hz) that corresponds to a bin (position) in a real-FFT vector, given sampling rate sr and window length wl. The FFT vector is assumed to be 1-based, as always in Julia.\n\nIf DC is false, the first discrete frequency is assumed to be at bin 1, otherwise the DC level is assumed to be at bin 1 and the first discrete frequency at bin 2.\n\nSee also: f2b, fres, fdf, brange.\n\nExamples:\n\nusing FourierAnalysis\nf2b(20, 512, 1024) # return 40\nf2b(10, 128, 128) # return 10\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.fdf","page":"Tools","title":"FourierAnalysis.fdf","text":"function fdf(sr :: Int,\n             wl :: Int;\n          DC :: Bool = false)\n\nReturn a vector with all Fourier discrete frequencies for a real-FFT, given sampling rate sr and window length wl. If DC is false, the first discrete frequency starts at bin (position) 1 and the length of the vector is wl2 (integer division), otherwise the DC level is at position 1. and the length of the vector is (wl2)+1.\n\nSee also: f2b, fres, b2f, brange.\n\nExamples:\n\nusing FourierAnalysis\nfdf(8, 16)\n# return the 8-element Array{Float64,1}:\n# [0.5, 1.0, 1.5, 2.0, 2.5, 3, 3.5, 4.0]\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.brange","page":"Tools","title":"FourierAnalysis.brange","text":"function brange(wl :: Int;\n             DC :: Bool = false)\n\nReturn a range of bins for a real-FFT vector covering all Fourier discrete frequencies given window length wl.\n\nIf DC is false, the range is 1(wl2) (integer division), otherwise it is 1(wl2)+1.\n\nSee also: f2b, fres, b2f, fdf.\n\nExamples:\n\nusing FourierAnalysis\nbrange(0.5, 8) # return 1:4\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.bbands","page":"Tools","title":"FourierAnalysis.bbands","text":"function bbands(sr :: Int,\n                wl :: Int,\n         bandwidth :: IntOrReal;\n    DC :: Bool = false)\n\nReturn a vector of integers holding the limits of all bandwidth-spaced band-pass regions of a real-FFT, in bins of discrete Fourier frequencies, from one to wl2 (integer division).\n\nThis is used by function bands.\n\nTo know the frequencies in Hz to which these bins correspond, call fbands.\n\nSee: bands.\n\nSee also: fbands.\n\nExamples:\n\nusing FourierAnalysis\nbbands(128, 256, 16) # return [1, 32, 64, 96, 128]\nfbands(128, 256, 16) # return [0.5, 16.0, 32.0, 48.0, 64.0]\n\nbbands(128, 256, 16; DC=true) # return [2, 33, 65, 97, 129]\nfbands(128, 256, 16; DC=true) # return [0.5, 16.0, 32.0, 48.0, 64.0]\n\nbbands(128, 128, 16) # return [1, 16, 32, 48, 64]\nfbands(128, 128, 16) # return [1.0, 16.0, 32.0, 48.0, 64.0]\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.fbands","page":"Tools","title":"FourierAnalysis.fbands","text":"function fbands(sr :: Int,\n                wl :: Int,\n         bandwidth :: IntOrReal;\n      DC :: Bool = false)\n\nReturn a vector of Frequencies (in Hz) to which the bins created by a call to function bbands with the same arguments correspond.\n\nSee: bbands.\n\nSee also: bands.\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.decibel","page":"Tools","title":"FourierAnalysis.decibel","text":"(1)\nfunction decibel(S :: Union{Real, AbstractArray{T}}) where T<:Real\n\n(2)\nfunction decibel(S1 :: Union{Real, AbstractArray{T}},\n            S2 :: Union{Real, AbstractArray{T}}) where T<:Real\n\nConvert (1) a measure S, or (2) a ratio between two measures S1./S2 into deciBels.\n\nInput measures can be real numbers or real arrays of any dimensions.\n\nFor array input, the ratio and the conversion is computed element-wise.\n\nExamples:\n\nusing FourierAnalysis\nv=sinusoidal(3., 1, 128, 256, 0)\ns=spectra(v, 128, 256; func=decibel) # compute the spectra in dB\ns.y # show the spectra\n\ndecibel(s.y)\n\ndecibel(10.0)\n\nN=abs.(randn(3, 3))\ndecibel(N)\n\n\n\n\n\n","category":"function"},{"location":"tools/#specific-methods","page":"Tools","title":"specific methods","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"function description\namplitude return the amplitude (modulus) of a complex number, complex array or TFAnalyticSignal object\nphase return the phase (argument) of a complex number, complex array or  TFAnalyticSignal object\npolar return the phase (argument) and amplitude (modulus) of a complex number, a complex array or TFAnalyticSignal object\nunwrapPhase compute and unwrap the phase of a complex array, unwrap a real array holding phase in [‚àíœÄ, œÄ], or construct a TFPhase object with the phase unwrapped\nisUnwrapped return true if the phase of all objects in a TFPhaseVector is unwrapped","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"amplitude\nphase\npolar\nunwrapPhase\nisUnwrapped","category":"page"},{"location":"tools/#FourierAnalysis.amplitude","page":"Tools","title":"FourierAnalysis.amplitude","text":"(1)\nfunction amplitude(c::Complex;\n                        func::Function=identity) = func(abs(c))\n\n(2)\nfunction amplitude(A::AbstractArray{T};\n                        func::Function=identity) where T<:Complex\n\n(3)\nfunction amplitude(A::TFAnalyticSignal;\n                        func::Function=identity)\n\n(4)\nfunction amplitude(ùêÄ::TFAnalyticSignalVector;\n                        func::Function=identity)\n\n(1)\n\nReturn the amplitude (modulus) of a complex number. This corresponds to Julia's abs function. It is here provided for syntactic consistency with the following methods.\n\n(2)\n\nReturn the amplitude of a complex array Z. Typically, Z holds analytic signal, in which case the output is the analytic (instantaneous) amplitude (also known as envelope). The output is a real array of the same size as Z.\n\n(3)\n\nReturn a real matrix with the analytic (instantaneous) amplitude of the TFAnalyticSignal object Z. The output is of the same size as the data field Z.y.\n\n(4)\n\nAs (3), but return a vector of amplitude matrices for all TFAnalyticSignal objects in ùêÄ\n\n~\n\nIn all methods if a function is provided by the optional keyword argument func, it is applied element-wise to the output. For example,\n\npassing func=x->x^2 will return the power,\npassing func=x->log(x^2) will return the log-power,\npassing func=x->decibel(x^2) will return the power in deciBels.\n\nSee: TFAnalyticSignal.\n\nExamples:\n\nusing FourierAnalysis, Plots\nx=sinusoidal(10, 2, 128, t*4, 0).*sinusoidal(10, 1, 128, t*4, 0)\n\n# amplitude and phase of a vector using analytic signal standard method\ny=analyticsignal(x)\na=amplitude(y)\nœï=phase(y, func=x->(x+œÄ)/2œÄ*50)\nplot([x, a, œï]; labels=[\"signal\", \"amplitude\", \"phase\"])\n\n# see what happen if `x` contains energy in frequencies below sr/wl Hz\n# (see documentation of `analyticSignal` function)\ny=analyticsignal(x, 64)\na=amplitude(y)\nœï=phase(y, func=x->(x+œÄ)/2œÄ*50)\nplot([x, a, œï]; labels=[\"signal\", \"amplitude\", \"phase\"])\n\n# unwrapped phase\n# the line below will do nothing as argument `unwrapdims` is 0 by default\nœï2=unwrapPhase(phase(y))\n# this will do the job\nœï2=unwrapPhase(phase(y); unwrapdims=1)\nplot([x, a, œï2./25]; labels=[\"signal\", \"amplitude\", \"unwr. phase\"])\n\n# amplitude from analytic signal of a data matrix holding multiple series\nX=randn(t, 4)\nY=analyticsignal(X)\nA=amplitude(Y)\nplot(A[:, 1:2])\n\n# phase\nùõ∑=phase(Y)\nplot(ùõ∑[:, 1:1])\n\n# unwrapped phase\nùõ∑2=unwrapPhase(ùõ∑; unwrapdims=1)\nplot(ùõ∑2)\n\n# phase represented in [-1, 1]\nùõ∑=phase(Y, func=x->(x+œÄ)/2œÄ)\nplot(ùõ∑[:, 1:1])\n\n# sine of the phase\nùõ∑=phase(Y, func=sin)\nplot(ùõ∑[:, 1:1])\n\n# get Amplitude and phase from analytic Signal\nA, ùõ∑=polar(Y)\nA\nùõ∑\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.phase","page":"Tools","title":"FourierAnalysis.phase","text":"(1)\nfunction phase(z::Complex; func::Function=identity)\n\n(2)\nfunction phase(Z::AbstractArray{T};\n                        unwrapdims::Int=0,\n                        func::Function=identity) where T<:Complex\n\n(3)\nfunction phase(Z::TFAnalyticSignal;\n                        unwrapped::Bool=false,\n                        func::Function=identity)\n\n(4)\nfunction phase(ùêô::TFAnalyticSignalVector;\n                        unwrapped::Bool=false,\n                        func::Function=identity)\n\n\n(1)\n\nReturn the phase (argument) of a complex number. This corresponds to a standard atan2 function. It is here provided for syntactic consistency with the following methods.\n\n(2)\n\nReturn the phase of a complex array Z. Typically, Z holds analytic signal, in which case the output is the analytic (instantaneous) phase. The output is a real array of the same size as Z.\n\nIf optional keyword argument unwrapdims is > 0, return the unwrapped phase along the unwrapdims dimension of the array. For example, if Z is a matrix, passing unwrapdims=1 unwrap the phase indipendently along its columns.\n\n(3)\n\nReturn a real matrix with the analytic (instantaneous) phase of the TFAnalyticSignal object Z. The output is of the same size as the data field Z.y.\n\nIf optional keyword argument unwrapped is true, return the unwrapped phase along the time dimension of the analytic signal (dims=2).\n\n(4)\n\nAs (3), but return a vector of phase matrices for all TFAnalyticSignal objects in ùöØ.\n\n~\n\nIn all methods by default the phase is returned in [‚àíœÄ, œÄ]. If a function is provided by the optional keyword argument func, it is applied to the phase. For example\n\npassing func=x->x+œÄ will return the phase in [0, 2œÄ],\npassing func=x->x/œÄ will return the phase in [-1, 1],\npassing func=sin will return the sine of the phase.\n\nnote: Nota Bene\nIf in method (2) unwrapdims is >0 or in method (3) and (4) unwrapped is true, the function func is applied to the unwrapped phase.\n\nSee: unwrapPhase, TFAnalyticSignal.\n\nExamples: see examples of amplitude.\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.polar","page":"Tools","title":"FourierAnalysis.polar","text":"(1)\nfunction polar(c::Complex)\n\n(2)\nfunction polar(Z::AbstractArray{T}) where T<:Complex\n\n(3)\nfunction polar(Z::TFAnalyticSignal)\n\n\n(1)\n\nReturn the amplitude (modulus) and phase (argument) of a complex number as a 2-tuple.\n\n(2)\n\nReturn the amplitude and phase of a complex array Z. Typically, Z holds analytic signal, in which case return the analytic (instantaneous) amplitude and phase. The output is a tuple of two real arrays of the same size as data field Z.y.\n\n(3)\n\nReturn the analytic (instantaneous) amplitude and phase of the TFAnalyticSignal object Z. The output is a tuple of two real arrays of the same size as data field Z.y.\n\n~\n\nIn all methods the phase is returned in [‚àíœÄ, œÄ].\n\nSee: amplitude, phase, TFAnalyticSignal.\n\nExamples: see examples of amplitude.\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.unwrapPhase","page":"Tools","title":"FourierAnalysis.unwrapPhase","text":"(1)\nfunction unwrapPhase(Z::AbstractArray{T};\n                                unwrapdims::Int=0) where T<:Complex\n\n(2)\nfunction unwrapPhase(œ¥::AbstractArray{T};\n                                unwrapdims::Int=0) where T<:Real\n\n(3)\nunwrapPhase(œ¥::TFPhase) [constructor of a TFPhase object]\n\n(4)\nunwrapPhase(ùöØ::TFPhaseVector) [constructor of a TFPhaseVector object]\n\n(1)\n\nIf optional keyword argument unwrapdims is > 0, compute the phase (argument) from a complex array and unwrap it along the unwrapdims dimension, otherwise (default) return Z. Typically, Z holds analytic signal.\n\n(2)\n\nIf optional keyword argument unwrapdims is > 0, unwrap along the unwrapdims dimension a real array holding phase data in [‚àíœÄ, œÄ], otherwise return œ¥.\n\n(3)\n\nConstruct a TFPhase object by unwrapping its phase along the time dimension and copying all other fields from the œ¥ object. If œ¥.func is different from the identity (do nothing) function, return instead an error message.\n\n(4)\n\nAs (3), but conctruct a TFPhaseVector holding TFPhase objects in ùöØ with the phase unwrapped. œ¥.func must be the identity function for all œ¥ ‚àà ùöØ.\n\nThe unwrapped phase is defined as the cumulative sum of the phase (along the relevant dimension) once this is represented in [0, 2œÄ].\n\nExamples: see examples of amplitude.\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.isUnwrapped","page":"Tools","title":"FourierAnalysis.isUnwrapped","text":"(1)\nfunction isUnwrapped(œ¥::TFPhase)\n\n(2)\nfunction isUnwrapped(ùöØ::TFPhaseVector)\n\n(1) Return true if the TFPhase objects œ¥ have the phase unwrapped.\n\n(2) Return true if all TFPhase objects in ùöØ have the phase unwrapped.\n\nSee: unwrapPhase, TFPhase, TFPhaseVector.\n\n\n\n\n\n","category":"function"},{"location":"tools/#generic-methods","page":"Tools","title":"generic methods","text":"","category":"section"},{"location":"tools/","page":"Tools","title":"Tools","text":"Generic methods applying to FDobjects, FDobjectsVector, TFobjects and TFobjectsVector:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"function description\nsmooth smooth the data across frequencies and/or across time\nextract extract the data in a frequency or time-frequency region\nmean compute the mean in a frequency or time-frequency region","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"¬§","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Generic methods applying only to FDobjects and FDobjectsVector:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"function description\nbands Return band-pass average of spectral, cross-spectral or coherence estimates in equally spaced band-pass regions","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"¬§","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"Generic methods applying to FDobjectsVector, and TFobjectsVector:","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"function description\nsameParams return true if the non-data fields of all objects in the vector have the same value\nisLinear return true if all objects in the vector are linear\nisNonLinear return true if all objects in the vector are non-linear","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"¬§","category":"page"},{"location":"tools/","page":"Tools","title":"Tools","text":"smooth\nextract\nmean\nbands\nsameParams\nisLinear\nisNonLinear","category":"page"},{"location":"tools/#FourierAnalysis.smooth","page":"Tools","title":"FourierAnalysis.smooth","text":"(1)\nfunction smooth(smoothing::Smoother,\n                v::Vector{R}) where R<:RealOrComplex\n\n\n(2)\nfunction smooth(smoothing::Smoother,\n                X::Matrix{R}; dims::Int=1) where R<:RealOrComplex\n\n(2)\nfunction smooth(smoother :: Smoother,\n                S :: Union{FDobjects, FDobjectsVector})\n\n(3)\nfunction smooth(fsmoothing :: Smoother,\n                tsmoothing :: Smoother,\n                Y :: Union{TFobjects, TFobjectsVector})\n\nApply a smoothing function of type Smoother to\n\n(1) a vector of real or complex numbers,\n(2) a real of complex matrix along dimension dims (default=1),\n(3) a FDobjects or all objects in a FDobjectsVector,\n(4) a TFobjects or all objects in a TFobjectsVector.\n\nMethods (1) and (2) are provided for low-level computations. Methods (3) and (4) are constructors; for all methods the output is always of the same type as the input.\n\nMethod (3) smooths across the frequency dimension:\n\nfor Spectra objects this amounts to smoothing the column vectors in their .y field,\nfor CrossSpectra and Coherence objects this amounts to smoothing adjacent matrices in their .y field.\n\nMethod (4) smooths across the frequency dimension, time dimension or both. This amounts to smoothing across the column vectors (frequency) and/or row vectors (time) in the .y field of the object. A smoother must be specified for the frequency dimension (fsmoothing) and for the time dimension (tsmoothing). Either one may be noSmoother, but if the two are different from noSmoother, then they must be the same. If smoothing is requested in both the frequency and time dimension, then the data is smoothed first in the time then in the frequency dimension. For TFPhase objects, smoothing is allowed only if the phase is unwrapped.\n\nThis function allow smoothing frequency domain and time-frequency domain objects after they have been created, however, smoothing can also be requested upon creation. For example, see the documentation of Spectra.\n\nnote: Nota Bene\nFor methods (1), (2) and (3), if Smoother is noSmoother, then the input is returned unchanged. For method (4) this is the case if both fsmoother and tsmoother are noSmoother.The data input must hold in the concerned dimension at least three elements for applying an Hann or Hamming smoother and at least five elements for applying the Blackman smoother.\n\nMaths\n\nSmoothing of a series x composed of k elements is carried out at element i such as\n\nx_i=ax_i-2+bx_i-1+cx_i+bx_i+1+ax_i+2.\n\nThe coefficients are\n\nsmoothing window a b c\nHann 0 0.25 0.50\nHamming 0 0.23 0.54\nBlackman 0.04 0.25 0.42\n\nFor 3-point smoothers, the first point is smoothed as\n\nx_1=fraccb+cx_1 + fracbb+cx_2\n\nand the last (the k^th) as\n\nx_k=fraccb+cx_k + fracbb+cx_k-1.\n\nFor 5-point smoothers, the first point is smoothed as\n\nx_1=fracca+b+cx_1 + fracba+b+cx_2 + fracaa+b+cx_3,\n\nthe second as\n\nx_2=fracba+2b+cx_1 + fracca+2b+cx_2 + fracba+2b+cx_3 + fracaa+2b+cx_4,\n\nthe second to last as\n\nx_k-1=fracaa+2b+cx_k-3 + fracba+2b+cx_k-2 + fracca+2b+cx_k-1 + fracba+2b+cx_k\n\nand the last as\n\nx_k=fracaa+b+cx_k-2 + fracba+b+cx_k-1 + fracca+b+cx_k.\n\nSee: Smoother\n\nExamples:\n\nusing FourierAnalysis, Plots\nsr, t, f, a = 128, 128, 10, 0.5\n# create a sinusoidal superimposed to white noise\nv=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)\n# compute Amplitude Spectra\nŒ£=spectra(v, sr, t; func=‚àö)\nbar(Œ£.y, labels=\"raw amplitude spectra\")\n\n#smooth spectra\nŒ£2=smooth(blackmanSmoother, Œ£)\nbar!(Œ£2.y, labels=\"smoothed amplitude spectra\")\n\n# smooth cross-spectra (or coherence) matrices\nX=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\nS=crossSpectra(X, sr, t) # or coherence (X, sr, t)\n# smooth the cross-spectra # or coherence\nS2=smooth(blackmanSmoother, S)\n\n# smooth time-frequency object\nY = TFanalyticsignal(v, sr, sr*4)\n# smooth frequency\nZ=smooth(blackmanSmoother, noSmoother, Y)\n# plot amplitude of smoothed analytic signal\nheatmap(Z, amplitude)\n\n# smooth AS: smooth both frequency and time\nE=smooth(blackmanSmoother, blackmanSmoother, Y)\n# plot real part of smoothed analytic signal\nheatmap(Z, real)\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.extract","page":"Tools","title":"FourierAnalysis.extract","text":"(1)\nfunction extract(S :: FDobjects,\n            frange :: fInterval)\n\n(2)\nfunction extract(ùêí :: FDobjectsVector,\n            frange :: fInterval;\n        w :: Vector = [],\n    check :: Bool   = true)\n\n(3)\nfunction extract(Y :: TFobjects,\n            frange :: fInterval,\n            trange :: tInterval)\n\n(4)\nfunction extract(ùíÄ :: TFobjectsVector,\n            frange :: fInterval,\n            trange :: tInterval;\n        w :: Vector = [],\n    check :: Bool   = true)\n\nalias: extr\n\nExtract data in a frequency region from FDobjects and data in a time-frequency region from TFobjects. The frequency and time region are indicated by frange and trange, which are of type fInterval and tInterval, respectively.\n\nThe input/output types of this function for a region with more then one frequency and more than one sample is reported in the following table:\n\nmethod input object output\n(1.1) Spectra a real matrix with spectra in frange arranged in columns¬π\n(1.2) CrossSpectra a vector of complex matrices holding the cross-spectra in frange¬≤\n(1.3) Coherence a vector of real matrices holding the coherence in frange¬≤\n(2.1) SpectraVector a vector of matrices of type (1.1)\n(2.2) CrossSpectraVector a vector of vectors of type (1.2)\n(2.3) CoherenceVector a vector of vectors of type (1.3)\n(3.1) TFAnalyticSignal a complex matrix holding the analytic signal in [frange, trange]\n(3.2) TFAmplitude a real matrix holding the amplitude in [frange, trange]\n(3.3) TFPhase a real matrices holding the phase in [frange, trange]\n(4.1) TFAnalyticSignalVector a vector of matrices of type (3.1)\n(4.2) TFAmplitudeVector a vector of matrices of type (3.2)\n(4.3) TFPhaseVector a vector of matrices of type (3.3)\n\nLegend: ¬π each column refers to a time-series on which the spectra have been computed. ¬≤ *depending on how the objects has been created, the matrices may be either Hermitian or LowerTriangular. See the documentation of CrossSpectra and Coherence.\n\nNote that depending on the arguments the type of the output may loose one or two dimensions. For instance,\n\nif the Spectra object holds only one spectrum, (1.1) will output a column vector and (2.1) a vector of column vectors.\nif frange points to a single frequency, (1.1) will output a row vector and (2.1) a vector of row vectors.\nif both the above two conditions hold, (1.1) will output a real number and (2.1) a vector.\nif frange points to a single frequency, (1.2), (1.3) will output a matrix and (2.2), (2.3) a vector of matrices.\nIf frange points to a single frequency band, (3.1), (3.2), (3.3) will output a row vector and (4.1), (4.2), (4.3) a vector of row vectors.\nIf trange points to a single time sample, (3.1), (3.2), (3.3) will output a column vector and (4.1), (4.2), (4.3) a vector of column vectors.\nif both the above two conditions hold, (3.1), (3.2), (3.3) will output a number and (4.1), (4.2), (4.3) a vector.\n\nMethod (2) and (4) allows the following optional keyword arguments:\n\nw, a k-vector of non-negative integers or real numbers, where k is the numbers of objects hold in the input FDobjectsVector or TFobjectsVector. w is a vector of weights for the regions extracted from the input objects. By default, no weights are assigned.\n\ncheck, a boolean. If it is true (default), it is checked that the non-data fields of the input objects are all the same (for example, sampling rate, bandwidth, etc.). Set it to false to improve speed.\n\nSee also: mean.\n\nExamples:\n\nusing FourierAnalysis\n\n# example with univariate Spectra objects (one series -> one spectrum)\nsr, t, f, a = 128, 256, 10, 1\n# create a sinusoidal superimposed to white noise\nv=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)\n# compute univariate spectra\nŒ£=spectra(v, sr, t)\n# spectra in between 8Hz and 12Hz\ns=extract(Œ£, (8, 12))\n# spectra in between 8Hz and 12.5Hz\ns=extract(Œ£, (8, 12.5))\n# spectra at 10Hz\ns=extract(Œ£, 10) # or s=extract(S, (10, 10))\n# these two expressions are equivalent: s=extract(Œ£, :), s=Œ£.y\n\n# example with multivariate spectra (several series -> several spectra)\nŒ£=spectra(hcat(v, v+randn(t*16)), sr, t)\n# spectra in between 8Hz and 12Hz\nS=extract(Œ£, (8, 12))\n# spectra at 10Hz\nS=extract(Œ£, 10)\n\n# example with CrossSpectra objects (the same goes for Coherence objects)\nX=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\nŒ£=crossSpectra(X, sr, t)\n# cross-spectra in between 8Hz and 12Hz (Hermitian matrices)\nS=extract(Œ£, (8, 12))\nŒ£=crossSpectra(X, sr, t; tril=true)\n# cross-spectra in between 8Hz and 12Hz (LowerTriangular matrices)\nS=extract(Œ£, (8, 12))\n\n# example with multiple cross-spectra\nX2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\nŒ£=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector\nS=extract(Œ£, (8, 12); w=[0.4, 0.6])\n# now S[1] holds the cross-spectra in range 8-12Hz for X\n# and S[2] holds the cross-spectra in range 8-12Hz for X2\n\n# example with time-frequency objects\n# (work in the same way for TFAnalyticSignal, TFAmplitude and TFPhase)\nY = TFanalyticsignal(v, sr, t)\n# analytic signal within frequencies 8Hz and 12Hz and time samples 1 to 64.\nAS=extract(Y, (8, 12), (1, 64))\n\n# all analytic signal within frequencies 8Hz and 12Hz.\nAS=extract(Y, (8.0, 12), :) # accept integers and reals for frequencies\n\n# all analytic signal within time samples 1 to 64.\nAS=extract(Y, :, (1, 64))\n\n# example with multiple time-frequency objects\n# (notice how the type of the output changes)\nY = TFanalyticsignal([v, v+randn(t*16)], sr, t)\nAS=extract(Y, (8, 12), (1, 64))\nAS=extract(Y, (8), :)\nAS=extract(Y, 8, 2)\n\n\n\n\n\n","category":"function"},{"location":"tools/#Statistics.mean","page":"Tools","title":"Statistics.mean","text":"(1)\nfunction mean(S :: FDobjects,\n         frange :: fInterval)\n\n(2)\nfunction mean(ùêí :: FDobjectsVector,\n         frange :: fInterval;\n        w :: Vector = [],\n    check :: Bool   = true)\n\n(3)\nfunction mean(Y :: TFobjects,\n         frange :: fInterval,\n         trange :: tInterval)\n\n(4)\nfunction mean(ùíÄ :: TFobjectsVector,\n         frange :: fInterval,\n         trange :: tInterval;\n          w :: Vector = [],\n      check :: Bool   = true)\n\nReturn the mean of data in a frequency region from FDobjects and data in a time-frequency region from TFobjects. The frequency and time region are indicated by frange and trange, which are of type fInterval and fInterval, respectively.\n\nThe complete input/output types for this function is reported in the following table:\n\nmethod input object output\n(1.1) Spectra a vector holding the mean spectra in frange¬π\n(1.2) CrossSpectra a complex matrix holding the mean cross-spectra in frange¬≤\n(1.3) Coherence a real matrix holding the mean coherence in frange¬≤\n(2.1) SpectraVector a vector of vectors of type (1.1)\n(2.2) CrossSpectraVector a vector of matrices of type (1.2)\n(2.3) CoherenceVector a vector of matrices of type (1.3)\n(3.1) TFAnalyticSignal a complex number holding the mean analytic signal in [frange, trange]\n(3.2) TFAmplitude a real number holding the mean amplitude in [frange, trange]\n(3.3) TFPhase a real number holding the mean phase in [frange, trange]\n(4.1) TFAnalyticSignalVector a vector of numbers of type (3.1)\n(4.2) TFAmplitudeVector a vector of numbers of type (3.2)\n(4.3) TFPhaseVector a vector of numbers of type (3.3)\n\nlegend: ¬πeach element of the vector refers to a time-series on which the spectra have been computed. ¬≤ depending on how the objects has been created, the matrices may be either Hermitian or LowerTriangular.\n\nMethod (2) and (4) allows the following optional keyword arguments:\n\nw, a k-vector of non-negative integers or real numbers, where k is the numbers of objects hold in the input FDobjectsVector or TFobjectsVector. w is a vector of weights for the means extracted from the input objects. By default, no weights are assigned.\n\ncheck, a boolean. If it is true (default), it is checked that the non-data fields of the input objects are all the same (for example, sampling rate, bandwidth, etc.).\n\nSee also: extract.\n\nExamples:\n\nusing FourierAnalysis, Plots\n\n# example with univariate Spectra objects (one series -> one spectrum)\nsr, t, f, a = 128, 256, 10, 1\n# create a sinusoidal superimposed to white noise\nv=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)\n# compute the spectrum\nŒ£=spectra(v, sr, t)\n# mean spectrum in between 8Hz and 12Hz\ns=mean(Œ£, (8, 12))\n# mean spectrum in between 8Hz and 12.5Hz\ns=mean(Œ£, (8, 12.5))\n\n# example with multivariate spectra (several series -> several spectra)\nŒ£=spectra(hcat(v, v+randn(t*16)), sr, t)\n# mean spectra in between 8Hz and 12Hz\nS=mean(Œ£, (8, 12))\n# mean spectra at 10Hz, i.e., the spectra at 10Hz\nS=mean(Œ£, 10)\n\n# example with CrossSpectra objects (the same goes for Coherence objects)\nX=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\nŒ£=crossSpectra(X, sr, t)\n# mean cross-spectra in between 8Hz and 12Hz (an Hermitian matrix)\nS=mean(Œ£, (8, 12))\nŒ£=crossSpectra(X, sr, t; tril=true)\n# mean cross-spectra in between 8Hz and 12Hz (a LowerTriangular matrix)\nS=mean(Œ£, (8.0, 12.0)) # accept integers and reals for frequencies\n\n# example with multiple CrossSpectra objects\nX2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\nŒ£=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector\nS=mean(Œ£, (8, 12); w=[0.4, 0.6])\n# now S[1] will hold the mean cross-spectrum in range 8-12Hz for X\n# and S[2] will hold the mean cross-spectrum in range 8-12Hz for X2\n\n# example with time-frequency objects\n# (work in the same way for TFAnalyticSignal, TFAmplitude and TFPhase)\nY = TFanalyticsignal(v, sr, t)\n# mean analytic signal within frequencies 8Hz and 12Hz and time samples 1 to 64.\nas=mean(Œ£, (8, 12), (1, 64))\n# mean analytic signal within frequencies 8Hz and 12Hz.\nas=mean(Œ£, (8, 12), :)\n# mean analytic signal within time samples 1 to 64.\nas=mean(Œ£, :, (1, 64))\n\n# example with multiple time-frequency objects\nY = TFanalyticsignal([v, v+randn(t*16)], sr, t)\nAS=mean(Y, (8, 12), (1, 64))\n# get the mean across TFobjects of those means\nm=mean(mean(Y, (8, 12), (1, 64)))\nAS=mean(Y, (8), :)\nAS=mean(Y, 8, 2)\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.bands","page":"Tools","title":"FourierAnalysis.bands","text":"function bands(S :: Union{FDobjects, FDobjectsVector}\n       bandwidth :: IntOrReal)\n\nReturn band-pass average of spectral, cross-spectral or coherence estimates in equally spaced band-pass regions with the given bandwidth. bandwidth can be given as an integer or as a real number. See bbands for details on the definition of band-pass regions.\n\nBand-pass average is not supported for time-frequency objects as for those objects a similar averaging is natively avaiable using argument bandwidth in their constructors.\n\nThe output of this function is as it follows:\n\nfor univariate Spectra objects (i.e., those hodling one spectrum only), a real column vector,\nfor multivariate Spectra objects, a real matrix,\nfor SpectraVector objects, a vector of the above,\nfor CrossSpectra and Coherence objects, a vector of Hermitian or LowerTriangular matrices, depending on how the object has been cosntructed,\nfor CrossSpectraVector and CoherenceVector objects, a vector  of the above.\n\nSee: bbands.\n\nExamples:\n\nusing FourierAnalysis, Plots\n\n# example with univariate Spectra objects (one series -> one spectrum)\nsr, t, f, a = 128, 256, 10, 1\n# create a sinusoidal superimposed to white noise\nv=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)\n# compute the spectrum\nŒ£=spectra(v, sr, t)\n# mean spectra in 2Hz-band-pass regions\nb=bands(Œ£, 2)\nplot(b)\n\n# example with multivariate spectra (several series -> several spectra)\nŒ£=spectra(hcat(v, v+randn(t*16), v+randn(t*16) ), sr, t)\n# mean spectra in 2Hz-band-pass regions for all time-series\nb=bands(Œ£, 2)\nplot(b)\n# plot mean spectra in 2Hz-band-pass regions for time-series 2 and 3 only\nplot(bands(Œ£, 2)[:, 2:3])\n\n# example with CrossSpectra objects (the same goes for Coherence objects)\nX=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\nŒ£=crossSpectra(X, sr, t)\n# mean cross-spectra in 4Hz-band-pass regions\nB=bands(Œ£, 4)\n\n# example with multiple CrossSpectra objects\nX2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\nŒ£=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector\n# mean cross-spectra in 4Hz-band-pass regions for all cross-spectra objects\nB=bands(Œ£, 4)\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.sameParams","page":"Tools","title":"FourierAnalysis.sameParams","text":"function sameParams(ùêí        :: FDobjectsVector,\n                    funcname :: String)\n\nReturn true if all objects in ùêí have the same sr, wl, DC, taper, func(only for SpectraVector objects), nonlinear (only for CrossSpectraVector and CoherenceVector) and smoothing fields, otherwise print an error message pointing to the first field that is not identical in all objects and return Nothing. This method applies to all FDobjectsVector types, that is, to SpectraVector, CrossSpectraVector and CoherenceVector.\n\nfuncname is an optional string that the user can provide. It is inserted into the error message to locate the part of the code that generated the error. By defalut, \"unknown\" is used.\n\n\n\n\n\nfunction sameParams(ùíÄ        :: TFobjectsVector,\n                    funcname :: String) =\n\nReturn true if all objects in ùíÄ have the same bandwidth, nonlinear, fsmoothing and tsmoothing field, otherwise print an error message pointing to the first field that is not identical in all objects and return Nothing. This method applies to all TFobjectsVector types, that is, TFAnalyticSignalVector, TFAmplitudeVector and TFPhaseVector.\n\nfuncname has the same meaning as in the previous method.\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.isLinear","page":"Tools","title":"FourierAnalysis.isLinear","text":"function isLinear(ùíÄ::Union{FDobjectsVector, TFobjectsVector})\n\nReturn true if all objects in ùíÄ are linear. By definition, Spectra and TFAmplitude objects are linear. CrossSpectra, Coherence, TFAnalyticSignal and TFPhase objects may be linear or non-linear.\n\nSee:FDobjectsVector, TFobjectsVector.\n\n\n\n\n\n","category":"function"},{"location":"tools/#FourierAnalysis.isNonLinear","page":"Tools","title":"FourierAnalysis.isNonLinear","text":"function isNonLinear(ùíÄ::Union{FDobjectsVector, TFobjectsVector})\n\nReturn true if all objects in ùíÄ are non-linear. By definition, Spectra and TFAmplitude objects are linear. CrossSpectra, Coherence, TFAnalyticSignal and TFPhase objects may be linear or non-linear.\n\nSee:FDobjectsVector, TFobjectsVector.\n\n\n\n\n\n","category":"function"},{"location":"timefrequencybi/#timefrequencybi.jl","page":"TF Bivariate Measures ","title":"timefrequencybi.jl","text":"","category":"section"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"This unit implements average time-frequency bivariate measures based on unit timefrequency.jl and tools.jl.","category":"page"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"These measures are bivariate extension of the mean amplitude, concentration and phase concentration univariate measures implemented in timefrequencyuni.jl, as explained in details in Congedo (2018). Please read the documentation of that unit first, as it contains useful information on how time-frequency measures are estimated and explain the notation used here below.","category":"page"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"The implemented measures are:","category":"page"},{"location":"timefrequencybi/#(weighted)-comodulation","page":"TF Bivariate Measures ","title":"(weighted) comodulation","text":"","category":"section"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"(w)Com=leftwr_1r_2rightbig sqrtleftwr_1^2rightleftwr_2^2right.","category":"page"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"This is the bivariate extension of univariate (weighted) mean amplitude measure.","category":"page"},{"location":"timefrequencybi/#(weighted)-coherence","page":"TF Bivariate Measures ","title":"(weighted) coherence","text":"","category":"section"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"This is the bivariate extension of the concentration and phase concentration measure, yielding coherence and phase coherence estimates, the latter also known as phase-locking value.","category":"page"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"For a complete account on coherence estimations in the time-frequency domain and the difference with their frequency domain counterpart see the coherence.jl unit, where the documentation of the coherence functions is also found.","category":"page"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"comodulation","category":"page"},{"location":"timefrequencybi/#FourierAnalysis.comodulation","page":"TF Bivariate Measures ","title":"FourierAnalysis.comodulation","text":"(1)\nfunction comodulation( ùêÄ‚ÇÅ     :: TFAnalyticSignalVector,\n                       ùêÄ‚ÇÇ     :: TFAnalyticSignalVector,\n                       frange :: fInterval,\n                       trange :: tInterval;\n                  mode  :: Function = extract,\n                  func  :: Function = identity,\n                  w     :: Vector = [],\n                  check :: Bool   = true) =\n\n(2)\nfunction comodulation( ùêô‚ÇÅ     :: TFAnalyticSignalVector,\n                       ùêô‚ÇÇ     :: TFAnalyticSignalVector,\n    < arguments frange, trange, mode, func, w and check as in method (1) >\n\n(3)\nfunction comodulation(ùê±‚ÇÅ        :: Vector{Vector{T}},\n                      ùê±‚ÇÇ        :: Vector{Vector{T}},\n                      sr        :: Int,\n                      wl        :: Int,\n                      frange    :: fInterval,\n                      trange    :: tInterval,\n                      bandwidth :: IntOrReal    = 2;\n                mode            :: Function     = extract,\n                func            :: Function     = identity,\n                w               :: Vector       = [],\n                filtkind        :: FilterDesign = Butterworth(2),\n                fmin            :: IntOrReal    = bandwidth,\n                fmax            :: IntOrReal    = sr√∑2,\n                fsmoothing      :: Smoother     = noSmoother,\n                tsmoothing      :: Smoother     = noSmoother,\n                planner         :: Planner      = getplanner,\n                ‚è©             :: Bool         = true) where T<:Real\n\n\nalias: com\n\n(1)\n\nGiven a pair of TFAmplitudeVector objects, estimate their (weighted) comodulation measure. ùêÄ‚ÇÅ and ùêÄ‚ÇÇ must hold the same number of objects and the time-frequency planes of all the objects should be congruent.\n\narguments:\n\nfrange and trange have the same meaning as in the meanAmplitude method.\n\noptional keyword arguments\n\nmode, func and check have the same meaning as in the meanAmplitude method.\n\nw may be a vector of non-negative real weights associated to each pair of input objects. By default the unweighted version of the measure is computed.\n\n(2)\n\nGiven a pair of TFAnalyticSignalVector object, compute the amplitude of all objects and estimate the (weighted) comodulation as per method (1). Like in method (1), ùêô‚ÇÅ and ùêô‚ÇÇ must hold the same number of objects and the time-frequency planes of all the objects should be congruent. In addition, since using this method all TFAnalyticSignal objects in ùêô‚ÇÅ and ùêô‚ÇÇ must be linear, if check is true (default) and this is not the case, print an error and return Nothing. The checks on frange and trange performed by method (1) are also performed by this method.\n\n(3)\n\nEstimate the amplitude of all data vectors in ùê±‚ÇÅ and ùê±‚ÇÇ calling the TFamplitude constructor and then estimate the (weighted) comodulation measure across the constructed amplitude objects as per method (1).\n\nfrange, trange, mode, func, w and check have the same meaning as in method (1). The other arguments are passed to the TFamplitude constructors, to which the reader is referred for their meaning.\n\nIf a planner for FFT computations is not provided, it is computed once and applied for all amplitude estimations.\n\nSee also: coherence, timefrequencybi.jl.\n\nExamples:\n\nusing FourierAnalysis\n\n# generate 100 pairs of data vectors\nsr, t, bandwidth=128, 512, 2\nh=taper(harris4, t)\nùê±‚ÇÅ=[sinusoidal(2, 10, sr, t, 0).*h.y+randn(t) for i=1:100]\nùê±‚ÇÇ=[sinusoidal(2, 10, sr, t, 0).*h.y+randn(t) for i=1:100]\n\n# compute their (linear) analytic signal\nùêò‚ÇÅ=TFanalyticsignal(ùê±‚ÇÅ, sr, wl, bandwidth; fmax=32, nonlinear=false)\nùêò‚ÇÇ=TFanalyticsignal(ùê±‚ÇÇ, sr, wl, bandwidth; fmax=32, nonlinear=false)\n\n# compute their amplitude\nùêÄ‚ÇÅ=TFamplitude(ùêò‚ÇÅ)\nùêÄ‚ÇÇ=TFamplitude(ùêò‚ÇÇ)\n\n# compute the Com averaging in a TF region from TFAnalyticSignal objects\n# ùêò‚ÇÅ and ùêò‚ÇÇ must be linear\nCom=comodulation(ùêò‚ÇÅ, ùêò‚ÇÇ, (8, 12), :; mode=mean)\n\n# compute the Com averaging in a TF region from TFAmplitudeVector objects\n# ùêÄ‚ÇÅ and ùêÄ‚ÇÇ must be linear\nCom=comodulation(ùêÄ‚ÇÅ, ùêÄ‚ÇÇ, (8, 12), :; mode=mean)\n\n# compute the Com averaging in a TF region directly from data\n# In this case you don't have to worry about linearity\nCom=comodulation(ùê±‚ÇÅ, ùê±‚ÇÇ, sr, wl, (8, 12), :, bandwidth; mode=mean)\n\n# compute comodulation from smoothed amplitude:\nCom=comodulation(ùê±‚ÇÅ, ùê±‚ÇÇ, sr, wl, (8, 12), :, bandwidth;\n                 mode=mean,\n                 fsmoothing=blackmanSmoother,\n                 tsmoothing=blackmanSmoother)\n\n# you can go faster pre-computing a FFTW plan.\n# This is useful when you have to call the comodulation function several times\nplan=Planner(plan_patient, 5, wl, Float64, true)\nCom=comodulation(ùê±‚ÇÅ, ùê±‚ÇÇ, sr, wl, (8, 12), :, bandwidth; mode=mean, planner=plan)\n\n# compute the Com in a TF region from TFAnalyticSignalVector objects\nCom=comodulation(ùêò‚ÇÅ, ùêò‚ÇÇ, (8, 12), :; mode=extract)\n\n# compute the Com in a TF region from TFAmplitudeVector objects\nCom=comodulation(ùêÄ‚ÇÅ, ùêÄ‚ÇÇ, (8, 12), :; mode=extract)\n\n# compute the Com in a TF region directly from data\nCom=comodulation(ùê±‚ÇÅ, ùê±‚ÇÇ, sr, wl, (8, 12), :, bandwidth; mode=extract)\n\n# All these operations can be done also for coherence measures, for example\nCoh=coherence(ùêò‚ÇÅ, ùêò‚ÇÇ, (8, 12), :; mode=mean)\n\nCoh=coherence(ùêò‚ÇÅ, ùêò‚ÇÇ, (8, 12), :; mode=extract)\n\n# Compute all 5 coherence types\nCoh=coherence(ùêò‚ÇÅ, ùêò‚ÇÇ, (8, 12), :; mode=extract, allkinds=true)\n\n# phase coherence (phase-locking value)\n# we obtain this measure from non-linear TFAnalyticSignalVector objects\nùêò‚ÇÅ=TFanalyticsignal(ùê±‚ÇÅ, sr, wl, bandwidth; fmax=32, nonlinear=true)\nùêò‚ÇÇ=TFanalyticsignal(ùê±‚ÇÇ, sr, wl, bandwidth; fmax=32, nonlinear=true)\n\nCoh=coherence(ùêò‚ÇÅ, ùêò‚ÇÇ, (8, 12), :; mode=mean, nonlinear=true)\n\n# or directly from data (no need to worry about non-linearity in this case)\nCoh=coherence(ùê±‚ÇÅ, ùê±‚ÇÇ, sr, wl, (8, 12), :, bandwidth; mode=mean, nonlinear=true)\n\n\n\n\n\n\n","category":"function"},{"location":"timefrequencybi/","page":"TF Bivariate Measures ","title":"TF Bivariate Measures ","text":"For coherence estimation in the time-frequency domain see coherence.","category":"page"},{"location":"crossspectra/#crossspectra.jl","page":"Cross-Spectral Matrices","title":"crossspectra.jl","text":"","category":"section"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Cross-spectra objects created by FourierAnalysis are incapsulated in the following structure:","category":"page"},{"location":"crossspectra/#CrossSpectra","page":"Cross-Spectral Matrices","title":"CrossSpectra","text":"","category":"section"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Categories: data objects, FDobjects.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"struct CrossSpectra\n    y           :: Union{Vector{LowerTriangular}, Vector{Hermitian}}\n    sr          :: Int\n    wl          :: Int\n    DC          :: Bool\n    taper       :: String\n    flabels     :: Vector{T} where T<:Union{Real, Int}\n    nonlinear   :: Bool\n    smoothing   :: Smoother\n    tril        :: Bool\nend","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Fields:","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"y: a real vector of LowerTriangular or Hermitian matrices (see Linear Algebra Julia standard package), depending on the tril field, as explained below, holding the cross-spectral matrices.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"sr: the sampling rate of the data on which the cross-spectra have been estimated.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"wl: the FFT window length used for estimating the cross-spectra.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"DC: if true, the first matrix holds the cross-spectra of the DC level, otherwise it holds the cross-spectra of the first positive frequency. Thus, if DC is false, the number of matrices in y is equal to wl2 (integer division), otherwise it is equal to (wl2)+1 (see Overview). In all constructors it is false by default.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"taper: the time-domain tapering window used for FFT computation, as a string, with parameters in parentheses for Slepian's dpss. See tapers.jl.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"flabels: a vector holding all Fourier discrete frequencies in Hz. Those are the frequency labels for the matrices in y. If DC is true, the first label is 0, otherwise it is the first positive frequency, which is equal to the frequency resolution srwl.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"nonlinear: if true, the amplitude information has been eliminated from the DFT coefficients, that is, the coefficients have been normalized by their modulus before being averaged to obtain the cross-spectra. This leads to non-linear estimates (Congedo, 2018; Pascual-Marqui 2007) where the diagonal elements of the cross-spectral matrices (the spectra) are 1.0 for all frequencies. In all constructors it is false by default.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"smoothing: a Smoother flag indicating whether the cross-spectral matrices have been smoothed across adjacent frequencies. If no smoothing has been applied, it is equal to noSmoother, which is the default in all constructors.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"tril: if false, the cross-spectral matrices in y are full Hermitian matrices, otherwise they are LowerTriangular matrices holding only the lower triangles of the cross-spectra. In all constructors it is false by default.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Note: In Julia the fields are accessed by the usual dot notation, e.g., you may verify that for CrossSpectra object S, length(S.flabels) == length(S.y)== (S.wl/2)+S.DC.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"A vector of CrossSpectra objects is of type CrossSpectraVector.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Methods for CrossSpectra and CrossSpectraVector objects","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"method CrossSpectra CrossSpectraVector\nbands ‚úî ‚úî\nextract ‚úî ‚úî\nmean ‚úî ‚úî\nsmooth ‚úî ‚úî\nsameParams  ‚úî\nisLinear  ‚úî\nisNonLinear  ‚úî","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Generic Constructors:","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"In order to construct a CrossSpectra object from multivariate data using the Welch method, FourierAnalysis provides two crossSpectra constuctors, which is what you will use in practice most of the time.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Manual constructors are also possible, for which you have to provide appropriate arguments. The default manual constructor of CrossSpectra objects is","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"CrossSpectra(y, sr, wl, DC, taper, flabels, nonlinear, smoothing, tril)","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Other constructors are also provided:","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"CrossSpectra(y, sr, wl, DC, taper, nonlinear)","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"enables construction giving only y, sr, wl, DC, taper and nonlinear argument. flabels is generated automatically, smoothing is set to noSmoother and tril is set to false;","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"CrossSpectra(y, sr, wl, taper)","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"as above, but setting by default also DC and nonlinear to false.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"Constructors from data:","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"crossSpectra","category":"page"},{"location":"crossspectra/#FourierAnalysis.crossSpectra","page":"Cross-Spectral Matrices","title":"FourierAnalysis.crossSpectra","text":"(1)\nfunction crossSpectra( X    :: Matrix{T},\n                       sr   :: Int,\n                       wl   :: Int;\n                  tapering  :: Union{Taper, TaperKind} = harris4,\n                  planner   :: Planner                 = getplanner,\n                  slide     :: Int                     = 0,\n                  DC        :: Bool                    = false,\n                  nonlinear :: Bool                    = false,\n                  smoothing :: Smoother                = noSmoother,\n                  tril      :: Bool                    = false,\n                  ‚è©       :: Bool                    = true) where T<:Real\n\n(2)\nfunction crossSpectra( ùêó    :: Vector{Matrix{T}},\n              < same argument sr, ..., ‚è© of method (1) > where T<:Real\n\n\n(1)\n\nConstruct a CrossSpectra objects from real multivariate data using the Welch method.\n\nGiven sampling rate sr and epoch length wl, compute the cross-spectral matrices of dimension nxn for a multivariate data matrix X of dimension txn, where t is the number of samples (rows) and n>1 is the number of time-series (columns).\n\nThe cross-spectral matrices are hold in the .y vector field of the created object. The length of .y depends upon the wl argument and DC optional keyword argument (see below).\n\nOptional Keyword Arguments:\n\nsr, wl, tapering, planner and slide have the same meaning as for the spectra function.\n\nDC: if true the cross-spectral matrix of the DC level is returned in the first position of y (see the fields of the CrossSpectra object), otherwise (default) the matrices in y start with the first positive discrete frequency, that is, srwl Hz.\n\nnonlinear: if true, the amplitude information is eliminated from the DFT coefficients, that is, they are normalized by their modulus before being averaged. This leads to non-linear estimates (Congedo, 2018; Pascual-Marqui 2007) where the diagonal elements of the cross-spectral matrices (the spectra) are 1.0 for all frequencies. By default, it is false.\n\nsmoothing: apply a smoothing function of type Smoother to the cross-spectral matrices across frequencies. By default no smoothing is applied.\n\ntril: if false (default), the whole cross-spectra matrices will be computed, otherwise only their lower triangular part (see below).\n\n‚è©: if true (default), the method is run in multi-threaded mode across the series in X if the number of series is at least twice the number of threads Julia is instructed to use. See Threads.\n\nReturn\n\nIf tril is false (default), the output is of type Array{Hermitian,1}, which is the ‚ÑçVector type used in package PosDefManifold. Since cross-spectral estimates are Hermitian positive definite, they can be straightaway used as argument to PosDefManifold's functions, e.g., for computing matrix moves on geodesics, matrix distances, etc. and the the whole vector output to compute matrix means, spectral embedding and more.\n\nIf tril is true, the output is of type Array{LowerTriangular,1}, which is the ùïÉVector type used in PosDefManifold, that is, only the lower triangle of the cross-spectra is computed in order to save time and memory.\n\n(2)\n\nConstruct a CrossSpectraVector object from a vector of real multivariate data matrices. Compute the cross-spectral matrices using the Welch method as per method (1) for all k data matrices in ùêó.\n\nThe k matrices in ùêó must have the same number of columns (i.e., the same number of time-series), but may have any number of (at least wl) rows (samples). All other arguments have the same meaning as in method (1), with the following difference:\n\n‚è©: if true (default), the method is run in multi-threaded mode across the k data matrices if k is at least twice the number of threads Julia is instructed to use, otherwise this method attempts to run each cross-spectral estimation in multi-threaded mode across series as per method (1). See Threads.\n\nIf a planner is not explicitly passed as an argument, the FFTW plan is computed once and applied for all cross-spectral estimations.\n\nReturn\n\nIf tril is false, the output is of type Array{Array{Hermitian,1},1}, which is the ‚ÑçVector‚ÇÇ type used in PosDefManifold.\n\nIf tril is true, the output is of type Array{Array{LowerTriangular,1},1}, which is the ùïÉVector‚ÇÇ type used in PosDefManifold.\n\nSee: CrossSpectra.\n\nSee also: spectra, coherence.\n\nExamples:\n\nusing FourierAnalysis, Plots, LinearAlgebra\n\nfunction generateSomeData(sr::Int, t::Int; noise::Real=1.)\n    # four sinusoids of length t samples and sr sampling rate\n    # peak amplitude: 0.7, 0.6, 0.5, 0.4\n    # frequency:        5,   7,  13,  27\n    # phase:            0, œÄ/4, œÄ/2,   œÄ\n    v1=sinusoidal(0.7, 5,  sr, t, 0)\n    v2=sinusoidal(0.6, 7,  sr, t, œÄ/4)\n    v3=sinusoidal(0.5, 13, sr, t, œÄ/2)\n    v4=sinusoidal(0.4, 27, sr, t, œÄ)\n    return hcat(v1, v2, v3, v4) + (randn(t, 4)*noise)\nend\n\nsr, wl, t = 128, 512, 8192\n\n# (1)\n\nX=generateSomeData(sr, t) # multivariate data matrix 8192x4\n\n# cross-spectra using default harris4 tapering window\nS=crossSpectra(X, sr, wl)\n\n# check the cross-spectral matrix at frequency 5Hz\nS.y[f2b(5, sr, wl)]\n\n# check only the diagonal part of this matrix as a vector\ndiag(Diagonal(S.y[f2b(5, sr, wl)]))\n\n# cross-spectra using hann tapering window\nS=crossSpectra(X, sr, wl; tapering=hann)\n\n# using Slepian's multi-tapering\nS=crossSpectra(X, sr, wl; tapering=slepians(sr, wl))\n\n# compute non-linear cross-spectra\nS=crossSpectra(X, sr, wl; tapering=slepians(sr, wl), nonlinear=true)\n\n# compute only the lower triangle of cross-spectral matrices\nS=crossSpectra(X, sr, wl; tapering=slepians(sr, wl), tril=true)\n\n# smooth a-posteriori the cross-spectra\nS2=smooth(blackmanSmoother, S)\n\n# or compute cross-spectra already smoothed\nS=crossSpectra(X, sr, wl;\n               tapering=slepians(sr, wl), tril=true, smoothing=blackmanSmoother)\n\n# mean cross-spectral matrix in 8Hz-12Hz range\nM=mean(S, (8, 12)) # or also M=mean(S, (8.0, 12.0))\n\n# extract all cross-spectral matrices in 8Hz-12Hz range\nE=extract(S, (8, 12))\n\n# cross-spectral matrices averaged in 2Hz band-pass regions\nB=bands(S, 2)\n\n# Get the spectra from a CrossSpectra object\nPowerSpectra=Spectra(S)\n\n# Get the amplitude spectra from a CrossSpectra object\nAmpSpectra=Spectra(S, func=‚àö)\n\n# Get the log10-spectra from a CrossSpectra object\nlog10Spectra=Spectra(S, func=log10)\n\n# plot the spectra (see recipes.jl)\nplot(AmpSpectra; fmax=32, xspace=4, ytitle=\"Amplitude\")\n\n# (2)\n# generate 3 multivariate data matrices 8192x4\nX=[generateSomeData(sr, t) for i=1:3]\n\n# The examples here below use exactly the same syntax as the previous method.\n# However, since the input here is a vector of data matrices\n# and not a single data matrix, the examples here below create a vector\n# of the object created by the examples above.\n# For example:\n\n# cross-spectra using the default harris4 tapering window\n# this creates a CrossSpectraVector object\nS=crossSpectra(X, sr, wl)\n\n# check the cross-spectral matrix at fr. 5Hz for the first CrossSpectra object\nS[1].y[f2b(5, sr, wl)]\n\n# check only the diagonal part of this matrix as a vector\ndiag(Diagonal(S[1].y[f2b(5, sr, wl)]))\n\n# cross-spectra using Hamming's tapering window\nS=crossSpectra(X, sr, wl; tapering=hamming)\n\n# using Slepian's multi-tapering\nS=crossSpectra(X, sr, wl; tapering=slepians(sr, wl))\n\n# compute non-linear cross-spectra\nS=crossSpectra(X, sr, wl; tapering=slepians(sr, wl), nonlinear=true)\n\n# compute only the lower triangle of cross-spectral matrices\nS=crossSpectra(X, sr, wl; tapering=slepians(sr, wl), tril=true)\n\n# smooth a-posteriori all CrossSpectra objects in S\nS2=smooth(blackmanSmoother, S)\n\n# or compute them all already smoothed\nS=crossSpectra(X, sr, wl; tapering=parzen, smoothing=blackmanSmoother)\n\n# mean cross-spectral matrix in 8Hz-12Hz range for all CrossSpectra (CS) objects\nM=mean(S, (8, 12)) # or also M=mean(S, (8.0, 12.0))\n\n# grand-average mean of the above across all CS objects\nmeanM=mean(mean(S, (8, 12)))\n\n# extract all cross-spectral matrices in 8Hz-12Hz range for all CS objects\nE=extract(S, (8, 12))\n\n# grand average of cross-spectral matrices in 8Hz-12Hz range for all CS objects\nmeanE=mean(extract(S, (8, 12)))\n\n# cross-spectral matrices averaged in 2Hz band-pass regions for all CS objects\nB=bands(S, 2)\n\n# Get and plot the spectra from a CrossSpectra object\nplot(Spectra(S[1]); fmax=32, xspace=4)\n\n# Pre-compute a FFT planner and pass it as argument\n# (this interesting if the function is to be called repeatedly).\nplan=Planner(plan_exhaustive, 10.0, wl, eltype(X[1])) # wait 10s\nS=crossSpectra(X, sr, wl; planner=plan)\n\n# how faster is this?\nusing BenchmarkTools\n@benchmark(crossSpectra(X, sr, wl))\n@benchmark(crossSpectra(X, sr, wl; planner=plan))\n...\n...\n\n\n\n\n\n\n\n","category":"function"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"References:","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"M. Congedo (2018), Non-Parametric Synchronization Measures used in EEG and MEG, Technical Report. GIPSA-lab, CNRS, University Grenoble Alpes, Grenoble INP.","category":"page"},{"location":"crossspectra/","page":"Cross-Spectral Matrices","title":"Cross-Spectral Matrices","text":"R. Pascual-Marqui (2007), Instantaneous and lagged measurements of linear and nonlinear dependence between groups of multivariate time series: frequency decomposition, arXiv:0711.1455.","category":"page"},{"location":"tapers/#tapers.jl","page":"Tapering Windows","title":"tapers.jl","text":"","category":"section"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"This unit implements eight tapering windows and the discrete prolate spheroidal sequences, the latter via the DSP package.","category":"page"},{"location":"tapers/#TaperKind","page":"Tapering Windows","title":"TaperKind","text":"","category":"section"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"@enum TaperKind begin\n    rectangular = 1\n    triangular  = 2\n    hann        = 3\n    hamming     = 4\n    blackman    = 5\n    harris4     = 6\n    riesz       = 7\n    parzen      = 8\n    slepian     = 9\nend","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"note: Using hamming and blackman tapers\nThose two identifiers conflicts with the DSP package. Until a better solution is found, invoke them as FourierAnalysis.hamming and FourierAnalysis.blackman.","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"The Hann tapering window is also known as 'squared cosine' window and a the Riesz window is similar to a window known as the 'cosine' window.","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"The design of tapering windows implies a trade-off between the equivalent noise bandwidth (enb), the energy of the first sidelobe (fsl) and the rate of sidelobe falloff (slf). The characteristics of the implemented tapering windows are reported in the following table:","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"window notable points enb(bins) fsl(dB) slf(dB/octave)\nrectangular 1 everywhere 1 -13 - 6\ntriangular 0 at boundaries 1.33 -26 -12\nhann 0 at boundaries 1.50 -32 -18\nhamming >0 at boundaries 1.36 -43 - 6\nblackman 0 at boundaries 1.73 -58 -18\nharris4 >0 at boundaries 2 -92 - 6\nriesz 0 at boundaries 1.2 -21 -12\nparzen >0 at boundaries 1.92 -53 -24","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"The harris4 tapering window features excellent first sidelobe (-92dB) and sidelob falloff (-6dB rate), at the expenses of the highest equivalent noise bandwidth among all. Since this latter parameter is not critical in many applications, this window is employed as default by all FourierAnalysis constructors of objects in the frequency domain.","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"For reducing the variance of the spectral estimations, use the (Slepian) discrete prolate spheroidal sequences (dpss) multi-tapering (see slepians).","category":"page"},{"location":"tapers/#Taper","page":"Tapering Windows","title":"Taper","text":"","category":"section"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"Tapering windows in FourirAnalysis are encapsulated in the following structure:","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"struct Taper\n    y    :: Union{Vector{T}, Matrix{T}} where T<:Real\n    kind :: TaperKind\n    Œ±    :: Real\n    n    :: Int\nend","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"The fields of the structure are:","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"y, a real vector holding the tapering window, but for Slepian multi-tapers, for which this is a matrix holding in its columns the dpss\nkind, the tapering window(s) as a TaperKind\nŒ±, a parameter for the tapering window(s). This is needed only for dpss\nn, the number of tapering windows. It is >1 only for dpss.","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"If you need to construct Taper objects for single tapering windows, use the universal taper constructor. For constructing dpss use the specialized constructor slepians.","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"taper\nslepians\ntaperinfo","category":"page"},{"location":"tapers/#FourierAnalysis.taper","page":"Tapering Windows","title":"FourierAnalysis.taper","text":"function taper( kind  :: TaperKind,\n                wl    :: Int;\n            Œ±       :: Real    = 2.,\n            n       :: Int     = ceil(Int, 2*Œ±)-1,\n            padding :: Int     = 0,\n            type    :: Type{T} = Float64) where T<:Union{Real, Complex}\n\n\nUniversal constructor of Taper objects, given a tapering window kind, of type TaperKind and the window length wl.\n\nReturn a vector of length wl for all types of tapers, but for the dpss (Slepian multi-tapers), for which return a matrix of size wl x n.\n\nIf optional keyword argument padding is >0, then the actual window length will be wl + padding.\n\nThe type optional keyword argument can be use to specify the the type of elements of the typering window. By default, this is the Float64 type.\n\nOptional keywords arguments Œ± and n currently apply only for slepian multi-tapering (discrete prolate spheroidal sequences):\n\nŒ± is the half bandwidth (hbw) parameter as per the DSP.jl package. This unit is used in many dpss implementations and it is often reported that \"typical values\" for Œ± are 2, 2.5, 3, 3.5 or 4. However, the optimal smoothing increases with the ratio between window length and sampling rate, thus these values in absolute terms are not useful. In fact, the larger the hbw and the higher n, the smoother the spectra will be (variance reduction). In order to overcome these difficulties, for Slepian's multitapering FourirAnalysis implements the slepians constructor, which allows the bandwidth parameter to be given in Hz and the number of tapering windows to be chosen automatically.\n\nn is the number of tapering windows. For slepian tapers this is the number of the discrete prolate spheroidal sequences. As in the DSP package, by default it is set to ceil(Int, 2*Œ±)-1, however, depending on how large this number is, low eigenvalues may correspond to the last sequences, therefore those should be discarded.\n\nSee: plot tapering windows.\n\nSee also: slepians, taperinfo\n\nExamples:\n\nusing FourierAnalysis\n\n## Use the constructor\nsr, t, f, a = 128, 128, 10, 0.5\n# create a sinusoidal superimposed to white noise\nv=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)\n# create a data matrix\nX=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\n# compute spectra using hamming tapering window\n# we need to prepend 'FourierAnalysis.' since `hamming`\n# is declared also in DSP.jl\nH=taper(FourierAnalysis.hamming, t)\nS=spectra(X, sr, t; tapering=H)\n# you can obtain the same thing with\nS=spectra(X, sr, t; tapering=H)\n# which will create the hamming tapering window on the fly,\n# thus calling explicitly the constructor is interesting\n# only if you need to reuse the same tapering window many times.\n\n## Plot tapering windows using the standard plot function\nusing Plots\ntapers=[TaperKind(i) for i=1:8]\nX=zeros(t, 8)\nfor i=1:8 X[:, i] = taper(tapers[i], t).y end\nmylabels=Array{String}(undef, 1, 8)\nfor i=1:8 mylabels[1, i]=string(tapers[i]) end\nplot(X; labels=mylabels)\n\n## using the recipe declared in recipes.jl\nplot(taper(parzen, 256))\nplot(taper(slepian, 256, Œ±=4, n=7))\n\n\n\n\n\n\n","category":"function"},{"location":"tapers/#FourierAnalysis.slepians","page":"Tapering Windows","title":"FourierAnalysis.slepians","text":"Construct a Taper objects holding Slepian's multi-tapering discrete prolate spheroidal sequences, given sampling rate sr, window length wl and the bandwidth argument in Hz. For EEG data, 1<=bandwidth<=2 is an adequate choice.\n\nThe 'half-bandwidth' parameter Œ± used in the DSP package and in the universal Taper constructor is set as\n\n    `Œ±=(bandwidth/2)*wl/sr`.\n\nThe optimal number of dpss is heuristically set to\n\n    `n=max(1, trunc(Int, 2*Œ±)-trunc(Int, log(2*Œ±)))`.\n\nThe created object can be passed as argument in constructors spectra, crossSpectra and coherence.\n\nSee: plot tapering windows.\n\nExamples:\n\nusing FourierAnalysis\nsr, t, f, a = 128, 128, 10, 0.5\n# create a sinusoidal superimposed to white noise\nv=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)\n# create a data matrix\nX=broadcast(+, v, randn(t*16, 3))*randn(3, 3)\n# compute spectra using slepian multi-tapering with bandwidth 1.5\nH=slepians(sr, t, 2)\nS=spectra(X, sr, t; tapering=H)\n\nusing Plots\nplot(H)\nplot(S)\n\n\n\n\n\n","category":"function"},{"location":"tapers/#FourierAnalysis.taperinfo","page":"Tapering Windows","title":"FourierAnalysis.taperinfo","text":"function taperinfo(taper::Taper)\n\nReturn the name of the tapering window(s) encapsulated in the Taper object as a string.\n\nOnly for Slepian's discrete prolate spheroidal sequences (dpss), their parameters, namely, Œ± (half-bandwidth) and n (number of windows), are reported within parentheses as well.\n\nExamples:\n\nH=taper(hamming, 128*8)\ntaperinfo(H)\n\nH=slepians(128, 128*8, 2)\ntaperinfo(H)\n\n\n\n\n\n","category":"function"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"References","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"F.J. Harris (1978) On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform Proc. IEEE, 66, 51-53, 1978","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"D. Slepian (1978) Prolate Spheroidal Wave Functions. Fourier Analysis, and Uncertainty‚ÄîV: The Discrete Case The Bell System Technical Journal,VoL 57, No. 5. May-June 1978","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"D.J. Thomson (1982) Spectrum estimation and harmonic analysis Proc. IEEE 70: 1055-1096, 1982.","category":"page"},{"location":"tapers/","page":"Tapering Windows","title":"Tapering Windows","text":"More resources","category":"page"},{"location":"fftw/#fftw.jl","page":"FFTW planners","title":"fftw.jl","text":"","category":"section"},{"location":"fftw/","page":"FFTW planners","title":"FFTW planners","text":"This unit implements a convenient interface to FFTW.jl and AbstractFFTs.jl. It is not part of the main FourierAnalysis API, since all its functions manage basic FFTW plans for FFT and iFFT computations using default settings. However, the use of this unit is important if massive FFT computations are to be performed.","category":"page"},{"location":"fftw/","page":"FFTW planners","title":"FFTW planners","text":"In order to use effectively FFTW, see window length in FFTW.","category":"page"},{"location":"fftw/","page":"FFTW planners","title":"FFTW planners","text":"The following are constants used by FFTW as flags in creating FFT plans. See here for details.","category":"page"},{"location":"fftw/","page":"FFTW planners","title":"FFTW planners","text":"plan_estimate        = UInt32(64)      # (1 << 6)   very small search\nplan_measure         = UInt32(0)       #            small search\nplan_patient         = UInt32(32)      # (1 << 5)   large search\nplan_exhaustive      = UInt32(8)       # (1 << 3)   very large search\nplan_conserve_memory = UInt32(4)       # (1 << 2)\nplan_wisdom_only     = UInt32(2097152) # (1 << 21)\nplan_unaligned       = UInt32(2)       # (1 << 1)\nplan_preserve_input  = UInt32(16)      # (1 << 4)","category":"page"},{"location":"fftw/","page":"FFTW planners","title":"FFTW planners","text":"Planner","category":"page"},{"location":"fftw/#FourierAnalysis.Planner","page":"FFTW planners","title":"FourierAnalysis.Planner","text":"FFTW plans to be used by all functions in Fourier Analysis are incapsulated in this structure. This is the only operator object created by this package, all others being data objects.\n\nSpectral and cross-spectral computations (frequency domain objects) need only a forward plan (real FFT), while objects based on the analytic signal (time-frequency domain objects) need both a forward (.p) and a backward (.ip) plan (complex iFFT).\n\nArgument flags must be one of the constants here above. Basic usage of the flags involves a trade-off between the time needed to compute the planner and the efficacy for computing the FFTs. The following flags are sorted in ascending order of time needed to be computed and efficacy: plan_estimate, plan_measure, plan_patient, plan_exhaustive. By default FourierAnalysis adopts plan_estimate, which allows the quickest search, but the least optimal choice. Other flags may be worth if several FFT computations are to be done with the same setting. See here for details.\n\nArgument timelimit is the maximum time (in seconds) allowed to FFTW for optimizing the plans. Setting this to -1.0 amounts to imposing no time limits.\n\nFFTW plans are computed for a given window length wl and data type type.\n\nPlanners objects may be passed as an argument to constructors of FDobjects and TFobjects by using one of the Planner constuctor here below.\n\nConstructors\n\nPlanner(flags :: UInt32,\n    timelimit :: Union{Int, Float64},\n           wl :: Int,\n         type :: Type,\n           bw :: Bool = false)\n\nUse this to create a Planner object, passing as argument a FFTW flags constant and timelimit, the window length wl and the type of the input data type, which must be real, e.g., Float64.\n\nIf bw is false (default), a dummy backward plan is created, otherwise a backward plan is created for the complex data type corresponding to type (e.g., if type is Float64, it will created for ComplexF64 data.)\n\nFor example, suppose ùêó is a vector of many matrices of multivariate time-series sampled at 128 samples per second and that we want to compute the spectra for all of them using a 256-point FFT. We first create a plan by\n\np=Planner(plan_exhaustive, 10.0, 256, eltype(ùêó[1]))\n\nThen we invoke the Spectra function passing the plan as argument:\n\nùêí=spectra(ùêó, sr, t; planner=p)\n\nA shorter construction syntax is available when only the forward plan is needed and the type of the data is Float64:\n\nPlanner(flags :: UInt32,\n    timelimit :: Union{Int, Float64},\n           wl :: Int)\n\nFor example, the line above could have been written more shortly as\n\np=Planner(plan_exhaustive, 10.0, 256)\n\n\n\n\n\n","category":"type"},{"location":"#FourierAnalysis-Documentation","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"","category":"section"},{"location":"#Requirements-and-Installation","page":"FourierAnalysis Documentation","title":"Requirements & Installation","text":"","category":"section"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Julia version ‚â• 1.3","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Packages: see the dependencies of the main module.","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"To install the package, execute the following command in Julia's REPL:","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"]add FourierAnalysis","category":"page"},{"location":"#Contributions","page":"FourierAnalysis Documentation","title":"Contributions","text":"","category":"section"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Independent testing and reviewers for both the code and the documentation are welcome.","category":"page"},{"location":"#About-the-Author","page":"FourierAnalysis Documentation","title":"About the Author","text":"","category":"section"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Marco Congedo is a research scientist of CNRS (Centre National de la Recherche Scientifique), working in UGA (University of Grenoble Alpes), in Grenoble, France, the city where Jean-Baptiste Joseph Fourier has served as a Governor. Contact: first name dot last name at gmail dot com","category":"page"},{"location":"#Overview","page":"FourierAnalysis Documentation","title":"Overview","text":"","category":"section"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"FourierAnalysis allows the analysis of","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"sets of real multivariate time-series in the frequency domain,\nsets of real univariate time-series in the time-frequency domain.","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"The implemented tools may suit also other kind of data.","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Frequency-domain representations include spectra, linear and non-linear cross-spectral matrices and several linear and non-linear coherence matrices, which are all estimated using the sliding-windows (Welch) method.","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"For those estimations, keep in mind that given sampling rate sr and window length wl, the discrete Fourier frequencies are 0 1r 2r qr, where r=srwl is the frequency resolution and q=wl2 (integer division). The 0 (zero) frequency corresponds to the DC level, which estimation in FourierAnalysis is always given as an option.","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Time-frequency (TF) representations are obtained applying a filter-bank and the Hilbert  transform. This way FourierAnalysis computes the analytic signal, from which the instantaneous amplitude (envelope) and instantaneous phase are obtained, along with several popular linear and non-linear, weighted, univariate and bivariate statistics, such as the mean amplitude, mean direction, phase concentration, the non-linear version of which is a directional statistic known as circular mean resultant length, amplitude co-modulation, coherence, the non-linear version of which is a synchronization measure known as phase-locking values or phase coherence, etc.","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Such a large panel of measures is provided in a simple and unified fashion, following the approach illustrated in Congedo(2018) in the context of electroencephalography (EEG), for which all default settings have been tailored. The package has been written with the do-it-with-one-line spirit and with the aim of allowing full control over relevant options for the Fourier analysis of multivariate time-series.","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"For starting using this package, browse the code units listed here below and execute the many code examples you will find therein or execute the 'example.jl' units collected in the \"example\" folder distributed in the github repository.","category":"page"},{"location":"#Code-units","page":"FourierAnalysis Documentation","title":"Code units","text":"","category":"section"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"FourierAnalysis includes fourteen code units (.jl files):","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Main API Units Description\nMainModule (FourierAnalysis.jl) constants, types, some structs, tips & tricks\ntapers.jl tapering windows for spectral, cross-spectral and coherence analysis\nspectra.jl spectra of a time-series (set) or of a multivariate time series (set)\ncrossspectra.jl cross-spectral matrices of a multivariate time series (set)\ncoherence.jl coherence matrices of a multivariate time series (set)\ngoertzel.jl Goertzel's algorithms for estimating a single DFT coefficient\ntimefrequency.jl analytic signal, instantaneous amplitude and phase of a time-series set\ntimefrequencyuni.jl univariate measures of a time-series set\ntimefrequencybi.jl bivariate measures of a time-series set\nrecipes.jl plot recipes and tips to plot data created by Fourier Analysis\ntools.jl collection of useful functions","category":"page"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Other API Units Description\nfftw.jl interface to FFTW.jl to obtain forward and backward FFT planners\nfilters.jl interface to DSP.jl to apply filter-banks\nhilbert.jl computation of the analytic signal via Hilbert transform","category":"page"},{"location":"#Contents","page":"FourierAnalysis Documentation","title":"Contents","text":"","category":"section"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"Pages = [       \"index.md\",\n                \"MainModule.md\",\n                \"tapers.md\",\n                \"spectra.md\",\n                \"crossspectra.md\",\n                \"coherence.md\",\n                \"timefrequency.md\",\n                \"timefrequencyuni.md\",\n                \"timefrequencybi.md\",\n                \"recipes.md\",\n                \"tools.md\",\n                \"fftw.md\",\n                \"goertzel.md\",\n                \"filters.md\",\n                \"hilbert.md\"]\nDepth = 1","category":"page"},{"location":"#Index","page":"FourierAnalysis Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"FourierAnalysis Documentation","title":"FourierAnalysis Documentation","text":"","category":"page"},{"location":"recipes/#recipes.jl","page":"Plots","title":"recipes.jl","text":"","category":"section"},{"location":"recipes/","page":"Plots","title":"Plots","text":"This unit implements plot recipes for plotting data produced by Fourier Analysis.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"In the following recipes, operator --> sets the default plot attribute, while operator := forces the plot attribute to a specific value.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"note: Nota Bene\nWorking with plot recipes you must put the ; symbol in your argument list to separate optional keyword arguments.","category":"page"},{"location":"recipes/#plot-tapering-windows","page":"Plots","title":"plot tapering windows","text":"","category":"section"},{"location":"recipes/","page":"Plots","title":"Plots","text":"@recipe function f(::Type{Taper}, taper::Taper)\n    title               --> taperinfo(taper)\n    background_color    --> :white\n    gridcolor           --> :white\n    legend              --> false\n    dpi                 --> 300\n    taper.y\nend","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Plot the data of a Taper object, that is, the tapering window(s) hold in its .y field. This is a single tapering window for all kind of tapering windows, but for Slepian's discrete prolate spheroidal sequences, which are multi-tapering.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"The recipes allows to pass any other optional keyword argument of the standard Julia plot package.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Examples:","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"using FourierAnalysis, Plots\n\nplot(taper(parzen, 256))\nplot!(taper(harris4, 256))\n\n# discrete prolate spheroidal sequences\nH=taper(slepian, 256, Œ±=4, n=7)\nplot(H)","category":"page"},{"location":"recipes/#plot-spectra","page":"Plots","title":"plot spectra","text":"","category":"section"},{"location":"recipes/","page":"Plots","title":"Plots","text":"@recipe function f(::Type{Spectra}, S::Spectra;\n            fmax   = S.sr/2,\n            xspace = 4,\n            ytitle = \"Power (\\\\muV¬≤)\")\n\n    b=f2b(fmax, S.sr, S.wl)\n    xticstring=[\"$(xspace*i)\" for i=1:fmax√∑xspace]\n    pushfirst!(xticstring, \"$(fres(S.sr, S.wl))\")\n    xticrange=[1:S.wl/S.sr*xspace:b+1;]\n    for i=2:length(xticrange) xticrange[i]=xticrange[i]-1 end\n\n    legend         --> false\n    dpi            --> 300\n    xlabel         --> \"Frequency (Hz)\"\n    xticks         --> (xticrange, xticstring)\n    ylabel         --> ytitle\n    delete!(plotattributes, :fmax)\n    delete!(plotattributes, :xspace)\n    delete!(plotattributes, :ytitle)\n    S.y[1:(f2b(fmax, S.sr, S.wl; DC=S.DC)), :]\nend","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Plot the data in a Spectra object, e.g., plot all its spectra with separate lines.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Optional keyword argument fmax limits the plot on the right to the given frequency (in Hz).","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Optional keyword argument xspace (in Hz) determines the spacing between frequency ticks (x-axis).","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Optional keyword argument ytitle specifies a title for the y axis. The default is \"Power (\\muV¬≤)\"","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"The function allows to pass any other optional keyword argument of the standard Julia plot function.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Useful attributes for plotting spectra are:","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"xtickfont      = font(11, \"Times\"))\nytickfont      = font(11, \"Times\"))\nleft_margin    = 2mm\nbottom_margin  = 2mm\nxaxis          = (\"My x axis title\", font(11, \"Courier New\"))\nyaxis          = (\"My y axis title\", font(11, \"Courier New\"))\nlinecolor      = :grey","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"note: Nota Bene\nIn order to use the mm measure for margins you need to add using Plots.Measures in your script.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Examples:","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"using FourierAnalysis, Plots, Plots.Measures\n\nsr, t, f, a = 128, 128, 16, 0.5\n# create a sinusoidal at 16Hz superimposed to white noise\nv=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)\n# create a data matrix\nX=broadcast(+, v, randn(t*16, 3)) * randn(3, 3)\n\n# compute spectra using hamming tapering window\nS=spectra(X, sr, t; tapering=hann)\n\n# plot spectra\n\nplot(S) # quick and dirt\n\n# gather useful attributes to make nicer plots\nspectraArgs=(fmax=32,\n             xspace=4,\n             left_margin = 2mm,\n             bottom_margin = 2mm,\n             xtickfont = font(11, \"Times\"),\n             ytickfont = font(11, \"Times\"))\n\nplot(S; spectraArgs...)\n\n# compute and plot amplitude spectra\nS=spectra(X, sr, t; tapering=riesz, func=‚àö)\nplot(S; ytitle=\"Amplitude (\\\\muV)\", spectraArgs...)\n","category":"page"},{"location":"recipes/#plot-time-frequency-objects","page":"Plots","title":"plot time-frequency objects","text":"","category":"section"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Plots of data held by TFAnalyticSignal, TFAmplitude and TFPhase objects can be obtained with a simple call to the heatmap function of the Plots.jl package. The tfAxes function provides automatic labeling of the axes and is passed as the first argument.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"The second argument is the data matrix to be plotted. The matrix held in TFAmplitude and TFPhase objects is real, therefore it can be passed directly as argument. The matrix held in TFAnalyticSignal objects holds the analytic signal (AS), therefore it is complex. A function should be specified so as to transform it into a real matrix. Typical functions are:","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"real: return the real part of the AS\nimag: return the imaginary part of the AS\namplitude: return the AS amplitude\nphase: return the AS phase","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Note:","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Appropriate colors for plotting the real and imaginary part of the analytic signal, as well as the phase, are :pu_or, :bluesreds.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Appropriate colors for plotting amplitude and unwraped phase are :amp, :fire, :dimgray, :gwv.","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Useful attributes for plotting time-frequency objects are:","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"xtickfont      = font(10, \"Times\"))\nytickfont      = font(10, \"Times\"))\nright_margin   = 2mm\ntop_margin     = 2mm","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"Examples:","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"using FourierAnalysis, Plots, Plots.PlotMeasures\nsr, t, f, a, s = 128, 128, 8, 2.5, sinusoidal\n# create a sinusoidal at 8Hz modulated by a sinusoidal at 0.125Hz\n# and superimpose white noise\nv=s(a, f, sr, t*4, 0) .* s(a, 0.125, sr, t*4, 0) + randn(t*4)\nplot(v)\n\n# generate a times series with two frequencies\n# and a clear envelope\nsr, t, bandwidth=128, 512, 2\nh=taper(harris4, t)\nx1=sinusoidal(10, 8, sr, t, 0)\nx2=sinusoidal(10, 19, sr, t, 0)\nv=Vector((x1+x2).*h.y+randn(t))\nplot(v)\n\n# gather useful attributes to obtain nice heatmpap plots\ntfArgs=(right_margin = 2mm,\n        top_margin = 2mm,\n        xtickfont = font(10, \"Times\"),\n        ytickfont = font(10, \"Times\"))\n\n# compute the analytic signal (AS) of vector v\nY=TFanalyticsignal(v, sr, t; fmax=32)\n\n# plot the real part of the AS\nheatmap(tfAxes(Y)..., real(Y.y); c=:pu_or, tfArgs...)\n\n# ...the imaginary part of the AS\nheatmap(tfAxes(Y)..., imag(Y.y); c=:bluesreds, tfArgs...)\n\n# ...the amplitude of the AS\nheatmap(tfAxes(Y)..., amplitude(Y.y); c=:amp, tfArgs...)\n\n# ...the amplitude of the AS smoothed in the freq. dim.\nheatmap(tfAxes(Y)...,\n        amplitude(smooth(hannSmoother, noSmoother, Y).y);\n        c=:amp, tfArgs...)\n\n# ...the amplitude of the AS smoothed in freq. and time\nheatmap(tfAxes(Y)...,\n        amplitude(smooth(hannSmoother, hannSmoother, Y).y);\n        c=:amp, tfArgs...)\n\n# ...the phase of the AS\nheatmap(tfAxes(Y)..., phase(Y.y); c=:bluesreds, tfArgs...)\n\n# ...the phase of the AS weighted by the amplitude\nheatmap(tfAxes(Y)..., phase(Y.y).*amplitude(Y.y);\n        c=:bluesreds, tfArgs...)\n\n# compute a TF Amplitude obejct\nA=TFamplitude(v, sr, t; fmax=32)\n\n# plot the amplitude\nheatmap(tfAxes(A)..., A.y; c=:amp, tfArgs...)\n\n# compute a TF Phase obejct\nœ¥=TFphase(v, sr, t; fmax=32)\n\n# plot the phase\nheatmap(tfAxes(œ¥)..., œ¥.y; c=:pu_or, tfArgs...)\n\n# compute a TF Phase obejct with the phase unwrapped\nuwœ¥=TFphase(v, sr, t; unwrapped=true)\n\n# plot the unwrapped phase\nheatmap(tfAxes(uwœ¥)..., uwœ¥.y; c=:fire, tfArgs...)","category":"page"},{"location":"recipes/","page":"Plots","title":"Plots","text":"tfAxes","category":"page"},{"location":"recipes/#FourierAnalysis.tfAxes","page":"Plots","title":"FourierAnalysis.tfAxes","text":"Generate labels for the axes to be used in heatmap plots of TFobjects. On the y-axis the labels correspond to the center frequencies of the band-pass filter bank used to obtain the time-frequency representation, that is, to the .flabels field of the object.\n\nSee plot time-frequency objects for examples.\n\n\n\n\n\n","category":"function"}]
}
