<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TF Representations ¬∑ FourierAnalysis</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="FourierAnalysis logo"/></a><h1>FourierAnalysis</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">FourierAnalysis Documentation</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../tapers/">Tapering Window</a></li><li><span class="toctext">frequency domain</span><ul><li><a class="toctext" href="../spectra/">Spectral Estimations</a></li><li><a class="toctext" href="../crossspectra/">Cross-Spectral Matrices</a></li><li><a class="toctext" href="../coherence/">Coherence Matrices</a></li><li><a class="toctext" href="../goertzel/">Goertzel&#39;s Algorithms</a></li></ul></li><li><span class="toctext">time-frequency(TF) domain</span><ul><li class="current"><a class="toctext" href>TF Representations</a><ul class="internal"><li><a class="toctext" href="#TFAnalyticSignal-1">TFAnalyticSignal</a></li><li><a class="toctext" href="#TFAmplitude-1">TFAmplitude</a></li><li><a class="toctext" href="#TFPhase-1">TFPhase</a></li></ul></li><li><a class="toctext" href="../timefrequencyuni/">TF Univariate Measures</a></li><li><a class="toctext" href="../timefrequencybi/">TF Bivariate Measures </a></li></ul></li><li><span class="toctext">utilities</span><ul><li><a class="toctext" href="../plots/">Plots</a></li><li><a class="toctext" href="../tools/">Tools</a></li><li><a class="toctext" href="../fftw/">FFTW planners</a></li><li><a class="toctext" href="../filters/">Filter Banks</a></li><li><a class="toctext" href="../hilbert/">Hilbert Transform</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>time-frequency(TF) domain</li><li><a href>TF Representations</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/master/docs/src/timefrequency.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>TF Representations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="timefrequency.jl-1" href="#timefrequency.jl-1">timefrequency.jl</a></h1><p>This unit implements time-frequency representations based on analytic signal estimations. It uses the <a href="../filters/#filters.jl-1">filters.jl</a> unit for filtering the signals in a <a href="https://en.wikipedia.org/wiki/Filter_bank">filter bank</a> and the <a href="../hilbert/#hilbert.jl-1">hilbert.jl</a> unit for computing the <a href="https://en.wikipedia.org/wiki/Hilbert_transform">Hilbert transform</a>.</p><p>The main object in the time-frequency domain is the <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a>, from which the <a href="#TFAmplitude-1">TFAmplitude</a> and <a href="#TFPhase-1">TFPhase</a> objects are derived. Taken together these three objects are referred to as <a href="../MainModule/#TFobjects-1">TFobjects</a> and vectors of them are a <a href="../MainModule/#TFobjectsVector-1">TFobjectsVector</a> type.</p><table><tr><th style="text-align: center">Object</th><th style="text-align: center">Vector type</th><th style="text-align: center">Constructors from data</th></tr><tr><td style="text-align: center"><a href="#TFAnalyticSignal-1">TFAnalyticSignal</a></td><td style="text-align: center"><a href="../MainModule/#TFAnalyticSignalVector-1">TFAnalyticSignalVector</a></td><td style="text-align: center"><a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a></td></tr><tr><td style="text-align: center"><a href="#TFAmplitude-1">TFAmplitude</a></td><td style="text-align: center"><a href="../MainModule/#TFAmplitudeVector-1">TFAmplitudeVector</a></td><td style="text-align: center"><a href="#FourierAnalysis.TFamplitude"><code>TFamplitude</code></a></td></tr><tr><td style="text-align: center"><a href="#TFPhase-1">TFPhase</a></td><td style="text-align: center"><a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a></td><td style="text-align: center"><a href="#FourierAnalysis.TFphase"><code>TFphase</code></a></td></tr></table><h2><a class="nav-anchor" id="TFAnalyticSignal-1" href="#TFAnalyticSignal-1">TFAnalyticSignal</a></h2><p><strong>Categories</strong>: <a href="../MainModule/#data-objects-1">data objects</a>, <a href="../MainModule/#TFobjects-1">TFobjects</a>.</p><p>An analytic signal object has the following structure:</p><pre><code class="language-none">struct TFAnalyticSignal
    y          :: Matrix{T} where T&lt;:Complex
    bandwidht  :: IntOrReal
    flabels    :: Vector{S} where S&lt;:Real
    nonlinear  :: Bool
    fsmoothing :: Smoother
    tsmoothing :: Smoother
end</code></pre><p><strong>Fields</strong>:</p><p><code>y</code>: a <em>complex</em> matrix holding the <em>analytic signal</em> in the time-frequency domain, with frequency band-pass regions (in Hz) in rows and time (samples) in columns.</p><p><code>bandwidht</code>: the <em>bandwidht</em> (in Hz) of the filter bank band-pass regions. See constructor <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> for details. It can be an integer or a real number.</p><p><code>flabels</code>: a vector holding all center frequencies (in Hz) of the filter bank band-pass regions. Those are the <em>frequency labels</em> for the rows of <code>y</code>.</p><p><code>non-linear</code>: a flag indicating whether the analytic signal has been normalized so as to have amplitude<span>$1.0$</span> at all points. Such normalization allows non-linear univariate and bivariate estimations (see <a href="../timefrequencyuni/#timefrequencyuni.jl-1">timefrequencyuni.jl</a> and <a href="../timefrequencybi/#timefrequencybi.jl-1">timefrequencybi.jl</a>).</p><p><code>fsmoothing</code>: a flag of the <a href="../MainModule/#Smoother-1">Smoother</a> type indicating whether the analytic signal has been smoothed across adjacent frequency band-pass regions. If no frequency smoothing has been applied, it is equal to <code>noSmoother</code>, which is the default in all constructors.</p><p><code>tsmoothing</code>: a flag of the <a href="../MainModule/#Smoother-1">Smoother</a> type indicating whether the analytic signal has been smoothed across adjacent samples (time). If no time smoothing has been applied, it is equal to <code>noSmoother</code>, which is the default in all constructors.</p><p><strong>Note</strong>: In Julia the fields are accessed by the usual dot notation, e.g., you may verify that for <em>TFAnalyticSignal</em> object <code>Y</code>, <code>length(Y.flabels) == dim(Y.z, 1)</code>.</p><p>A vector of <em>TFAnalyticSignal</em> objects is of type <a href="../MainModule/#TFAnalyticSignalVector-1">TFAnalyticSignalVector</a>.</p><p><strong>Methods for TFAnalyticSignal and TFAnalyticSignalVector objects</strong></p><table><tr><th style="text-align: left">method</th><th style="text-align: center">TFAnalyticSignal</th><th style="text-align: center">TFAnalyticSignalVector</th></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.amplitude"><code>amplitude</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.phase"><code>phase</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.polar"><code>polar</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.extract"><code>extract</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#Statistics.mean"><code>mean</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.smooth"><code>smooth</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.sameParams"><code>sameParams</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.isLinear"><code>isLinear</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.isNonLinear"><code>isNonLinear</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../timefrequencyuni/#FourierAnalysis.meanAmplitude"><code>meanAmplitude</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../timefrequencyuni/#FourierAnalysis.concentration"><code>concentration</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../timefrequencybi/#FourierAnalysis.comodulation"><code>comodulation</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../timefrequencyuni/#FourierAnalysis.meanDirection"><code>meanDirection</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../coherence/#FourierAnalysis.coherence"><code>coherence</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr></table><p><strong>Generic Constructors</strong>:</p><p>In order to construct a <em>TFAnalyticSignal</em> object from univariate data, <em>FourierAnalysis</em> provides two <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> constuctors, which is what you will use in practice most of the time.</p><p>Manual constructors are also possible, for which you have to provide appropriate arguments. The default manual constructor of <em>TFAnalyticSignal</em> objects is</p><pre><code class="language-none">TFAnalyticSignal(y, bandwidht, flabels, nonlinear, fsmoothing, tsmoothing).</code></pre><p>No other generic constructor is provided for this object.</p><h2><a class="nav-anchor" id="TFAmplitude-1" href="#TFAmplitude-1">TFAmplitude</a></h2><p><strong>Categories</strong>: <a href="../MainModule/#data-objects-1">data objects</a>, <a href="../MainModule/#TFobjects-1">TFobjects</a>.</p><p>An amplitude object has the following structure:</p><pre><code class="language-none">struct TFAmplitude
    y          :: Matrix{T} where T&lt;:Real
    bandwidht  :: IntOrReal
    flabels    :: Vector{S} where S&lt;:Real
    fsmoothing :: Smoother
    tsmoothing :: Smoother
    func       :: Function
end</code></pre><p><strong>Fields</strong>:</p><p><code>y</code>: a <em>real</em> matrix holding the <em>amplitude</em> (modulus) of an analytic signal in the time-frequency domain, often referred to as the <em>envelope</em>, with frequency band-pass regions (in Hz) in rows and time (samples) in columns.</p><p><code>bandwidht</code>: the <em>bandwidht</em> (in Hz) of the filter bank band-pass regions. See constructor <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> for details. It can be an integer or a real number.</p><p><code>flabels</code>: a vector holding all center frequencies (in Hz) of the filter bank band-pass regions. Those are the <em>frequency labels</em> for the rows of <code>y</code>.</p><p><code>fsmoothing</code>: a flag of the <a href="../MainModule/#Smoother-1">Smoother</a> type indicating whether the amplitude has been smoothed across adjacent frequency band-pass regions. If no frequency smoothing has been applied, it is equal to <code>noSmoother</code>, which is the default in all constructors.</p><p><code>tsmoothing</code>: a flag of the <a href="../MainModule/#Smoother-1">Smoother</a> type indicating whether the amplitude has been smoothed across adjacent samples (time). If no time smoothing has been applied, it is equal to <code>noSmoother</code>, which is the default in all constructors.</p><p><strong>Note</strong>: Smoothing flags in this object indicate that the amplitude has been smoothed, whereas in the <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> object indicate that the analytic signal has been smoothed. Note that it is not equivalent to obtain amplitude from smoothed analytic signal (e.g., using the <a href="../tools/#FourierAnalysis.amplitude"><code>amplitude</code></a> function) or to smooth the amplitude of analytic signal, e.g., using the <a href="#FourierAnalysis.TFamplitude"><code>TFamplitude</code></a> constructor.</p><p><code>func</code>: a name of a function that has been applied element-wise to the matrix <code>.y</code> holding the amplitude. All constructors from data by default use the <code>identity</code> (do nothing) function.</p><p>A vector of <em>TFAmplitude</em> objects is of type <a href="../MainModule/#TFAmplitudeVector-1">TFAmplitudeVector</a>.</p><p><strong>Methods for TFAmplitude and TFAmplitudeVector objects</strong></p><table><tr><th style="text-align: left">method</th><th style="text-align: center">TFAmplitude</th><th style="text-align: center">TFAmplitudeVector</th></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.extract"><code>extract</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#Statistics.mean"><code>mean</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.smooth"><code>smooth</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.sameParams"><code>sameParams</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.isLinear"><code>isLinear</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.isNonLinear"><code>isNonLinear</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../timefrequencyuni/#FourierAnalysis.meanAmplitude"><code>meanAmplitude</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../timefrequencybi/#FourierAnalysis.comodulation"><code>comodulation</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr></table><p><strong>Generic Constructors</strong>:</p><p>In order to construct a <code>TFAmplitude</code> object from univariate data, <em>FourierAnalysis</em> provides four <a href="#FourierAnalysis.TFamplitude"><code>TFamplitude</code></a> constuctors, which is what you will use in practice most of the time.</p><p>Manual constructors are also possible, for which you have to provide appropriate arguments. The default manual constructor of <em>TFAmplitude</em> objects is</p><pre><code class="language-none">TFAmplitude(y, bandwidht, flabels, fsmoothing, tsmoothing, func).</code></pre><p>Other generic constructors are also provided:</p><pre><code class="language-none">TFAmplitude(y, bandwidht, flabels, fsmoothing, tsmoothing)</code></pre><p>enables construction giving only <code>y</code>, <code>bandwidth</code>, <code>flabels</code>, <code>fsmoothing</code> and <code>tsmoothing</code>. <code>func</code> is set automatically to <code>identity</code>;</p><pre><code class="language-none">TFAmplitude(y, bandwidht, flabels)</code></pre><p>acts like the constructor above, but sets by default also both <code>fsmoothing</code> and <code>tsmoothing</code> to <code>noSmoother</code>.</p><h2><a class="nav-anchor" id="TFPhase-1" href="#TFPhase-1">TFPhase</a></h2><p><strong>Categories</strong>: <a href="../MainModule/#data-objects-1">data objects</a>, <a href="../MainModule/#TFobjects-1">TFobjects</a>.</p><p>A phase object has the following structure:</p><pre><code class="language-none">struct TFPhase
    y          :: Matrix{T} where T&lt;:Real
    bandwidht  :: IntOrReal
    flabels    :: Vector{S} where S&lt;:Real
    nonlinear  :: Bool
    fsmoothing :: Smoother
    tsmoothing :: Smoother
    unwrapped  :: Bool
    func       :: Function
end</code></pre><p><strong>Fields</strong>:</p><p><code>y</code>: a <em>real</em> matrix holding the <em>phase</em> (argument) of an analytic signal in the time-frequency domain, with frequency band-pass regions (in Hz) in rows and time (samples) in columns. By default the phase is represented in <span>$[‚àíœÄ, œÄ]$</span>.</p><p><code>bandwidht</code>: the <em>bandwidht</em> (in Hz) of the filter bank band-pass regions. See constructor <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> for details. It can be an integer or a real number.</p><p><code>flabels</code>: a vector holding all center frequencies (in Hz) of the filter bank band-pass regions. Those are the <em>frequency labels</em> for the rows of <code>y</code>.</p><p><code>non-linear</code>: a flag indicating whether the phase has been estimated from analytic signal normalized so as to have amplitude<span>$1.0$</span> at all points. Such normalization allows non-linear univariate and bivariate estimations (see <a href="../timefrequencyuni/#timefrequencyuni.jl-1">timefrequencyuni.jl</a> and <a href="../timefrequencybi/#timefrequencybi.jl-1">timefrequencybi.jl</a>).</p><p><code>fsmoothing</code>: a flag of <a href="../MainModule/#Smoother-1">Smoother</a> indicating whether the phase has been smoothed across adjacent frequency band-pass regions. If no frequency smoothing has been applied, it is equal to <code>noSmoother</code>, which is the default in all constructors.</p><p><code>tsmoothing</code>: a flag of the <a href="../MainModule/#Smoother-1">Smoother</a> type indicating whether the phase has been smoothed across adjacent samples (time). If no time smoothing has been applied, it is equal to <code>noSmoother</code>, which is the default in all constructors.</p><p><strong>Note</strong>: Smoothing raw phase estimates is unappropriate since the phase is a discontinous function, however it makes sense to smooth phase if the phase is unwrapped (see below).</p><p><strong>Note</strong>: Smoothing flags in this object indicate that the (unwrapped) phase has been smoothed, whereas in the <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> object indicate that the analytic signal has been smoothed. Note that it is not equivalent to obtain unwrapped phase from smoothed analytic signal (e.g., using the <a href="../tools/#FourierAnalysis.phase"><code>phase</code></a> function) or to smooth the unwrapped phase of analytic signal, e.g., using the <a href="#FourierAnalysis.TFphase"><code>TFphase</code></a> constructor.</p><p><code>unwrapped</code>: a flag indicating if the phase has been unwrapped. The unwrapped phase is defined as the cumulative sum of the phase along the time dimension once the phase is represented in <span>$[0, 2œÄ]$</span>.</p><p><code>func</code>: a name of a function that has been applied element-wise to the matrix <code>.y</code> holding the phase. All constructors from data by default use the <code>identity</code> (do nothing) function. Examples of possible functions:</p><ul><li><code>func=x-&gt;x+œÄ</code> return the phase in [0, 2œÄ],</li><li><code>func=x-&gt;x/œÄ</code> return the phase in [-1, 1],</li><li><code>func=sin</code> return the sine of the phase.</li></ul><p>A vector of <em>TFPhase</em> objects is of type <a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a>.</p><p><strong>Methods for TFPhase and TFPhaseVector objects</strong></p><table><tr><th style="text-align: left">method</th><th style="text-align: center">TFAmplitude</th><th style="text-align: center">TFAmplitudeVector</th></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.unwrapPhase"><code>unwrapPhase</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.isUnwrapped"><code>isUnwrapped</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.extract"><code>extract</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#Statistics.mean"><code>mean</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.smooth"><code>smooth</code></a></td><td style="text-align: center">‚úî</td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.sameParams"><code>sameParams</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.isLinear"><code>isLinear</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr><tr><td style="text-align: left"><a href="../tools/#FourierAnalysis.isNonLinear"><code>isNonLinear</code></a></td><td style="text-align: center"></td><td style="text-align: center">‚úî</td></tr></table><p><strong>Generic Constructors</strong>:</p><p>In order to construct a <em>TFPhase</em> object from univariate data, <em>FourierAnalysis</em> provides four <a href="#FourierAnalysis.TFphase"><code>TFphase</code></a> constuctors, which is what you will use in practice most of the time.</p><p>Manual constructors are also possible, for which you have to provide appropriate arguments. The default manual constructor of <em>TFPhase</em> objects is</p><pre><code class="language-none">TFPhase(y, bandwidht, flabels, nonlinear,
        fsmoothing, tsmoothing, unwrapped, func).</code></pre><p>Other generic constructors are also provided:</p><pre><code class="language-none">TFPhase(y, bandwidht, flabels, nonlinear, fsmoothing, tsmoothing)</code></pre><p>enables construction giving only <code>y</code>, <code>bandwidht</code>, <code>flabels</code>, <code>fsmoothing</code> and <code>tsmoothing</code>. <code>unwrapped</code> is set to <code>false</code> and <code>func</code> is set to <code>identity</code>;</p><pre><code class="language-none">TFPhase(y, bandwidht, flabels)</code></pre><p>acts like the constructor above, but sets by default also <code>nonlinear</code> to <code>true</code> and both <code>fsmoothing</code> and <code>tsmoothing</code> to <code>noSmoother</code>.</p><p><strong>Constructors from data</strong>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.TFanalyticsignal" href="#FourierAnalysis.TFanalyticsignal"><code>FourierAnalysis.TFanalyticsignal</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function TFanalyticsignal(x         :: Vector{T},
                          sr        :: Int,
                          wl        :: Int          = 0,
                          bandwidht :: IntOrReal    = 2;
                      fmin          :: IntOrReal    = bandwidht,
                      fmax          :: IntOrReal    = sr√∑2,
                      filtkind      :: FilterDesign = Butterworth(2),
                      nonlinear     :: Bool         = false,
                      fsmoothing    :: Smoother     = noSmoother,
                      tsmoothing    :: Smoother     = noSmoother,
                      planner       :: Planner      = getplanner,
                      ‚è©           :: Bool         = true) where T&lt;:Real

(2)
function TFanalyticsignal(ùê±         :: Vector{Vector{T}},
                      &lt;same arguments as method (1)&gt;
</code></pre><p>(1)</p><p>Given sampling rate <code>sr</code>, construct a <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> object from univariate data <code>x</code>, that is, a time-frequency representation of real vector <code>x</code>.</p><p>Call three functions in series performing the three following operations:</p><p>i. pass the data throught a bank of pass-band filters calling function <a href="../filters/#FourierAnalysis.filterbank"><code>filterbank</code></a>,</p><p>ii. compute the analytic signal calling function <a href="../hilbert/#FourierAnalysis.analyticsignal"><code>analyticsignal</code></a> (method (1) therein),</p><p>iii. If requested, smooth the analytic signal along the time and/or frequency dimension calling function <a href="../tools/#FourierAnalysis.smooth"><code>smooth</code></a>.</p><p>The arguments passed to each of these functions are:</p><table><tr><th style="text-align: center">filterbank</th><th style="text-align: center">analyticsignal</th><th style="text-align: center">smooth</th></tr><tr><td style="text-align: center"><code>x</code></td><td style="text-align: center"><code>wl</code></td><td style="text-align: center"><code>fsmoothing</code></td></tr><tr><td style="text-align: center"><code>sr</code></td><td style="text-align: center"><code>nonlinear</code></td><td style="text-align: center"><code>tsmoothing</code></td></tr><tr><td style="text-align: center"><code>bandwidht</code></td><td style="text-align: center"><code>planner</code></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"><code>filtkind</code></td><td style="text-align: center"><code>‚è©</code></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"><code>fmin</code></td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"><code>fmax</code></td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"><code>‚è©</code></td><td style="text-align: center"></td><td style="text-align: center"></td></tr></table><p>Refer to the documentation of each function to learn the meaning of each argument.</p><p>By default the <code>wl</code> argument is set to <code>length(x)</code>.</p><p>If <code>‚è©</code> is true (default), filtering and computation fo the analytic signal are multi-threaded across band-pass regions as long as the number of the regions is at least twice the number of threads Julia is instructed to use. See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>(2)</p><p>Given sampling rate <code>sr</code>, construct a <a href="../MainModule/#TFAnalyticSignalVector-1">TFAnalyticSignalVector</a> object from a vector of univariate data <code>ùê±</code>, that is, from the time-frequency representations of the vectors in <code>ùê±</code>.</p><p>This method operates as method (1) with the following exceptions:</p><p>By default the <code>wl</code> argument is set to <code>length(x)</code> for each vectors in <code>ùê±</code>. If another values is given, it will be used for all of them.</p><p>If <code>‚è©</code> is true (default), the method is run in multi-threaded mode across the vectors in <code>ùê±</code> as long as their number is at least twice the number of threads Julia is instructed to use, otherwise this method attempts to run each analytic signal estimation in multi-threaded mode like in method (1). See <a href="../MainModule/#Threads-1">Threads</a>.</p><p>If a <code>Planner</code> is not explicitly passed as an argument, the FFTW plan is computed once and applied for all analytic signal estimations.</p><p><strong>See</strong>: <a href="../filters/#FourierAnalysis.filterbank"><code>filterbank</code></a>, <a href="../hilbert/#FourierAnalysis.analyticsignal"><code>analyticsignal</code></a>, <a href="../tools/#FourierAnalysis.smooth"><code>smooth</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using Plots, FourierAnalysis

# generate some data
sr, t, bandwidht=128, 512, 2
h=taper(harris4, t)
x1=sinusoidal(10, 8, sr, t, 0)
x2=sinusoidal(10, 19, sr, t, 0)
x=Vector((x1+x2).*h.y+randn(t))
y1=sinusoidal(10, 6, sr, t, 0)
y2=sinusoidal(10, 16, sr, t, 0)
y=Vector((y1+y2).*h.y+randn(t))
plot([x, y])

# TFAnalyticSignal object for x (method (1))
Y = TFanalyticsignal(x, sr, sr*4)

# vector of TFAnalyticSignal objects for x and y (method (2))
ùíÄ = TFanalyticsignal([x, y], sr, sr*4)

# (for shortening comments: TF=time-frequency, AS=analytic signal)

# mean AS in a TF region (8:12Hz and samples 1:128) for the first object
m=mean(ùíÄ[1], (8, 12), (1, 128)) # Output a complex number

# extract the AS in a TF region (8:12Hz and samples 1:128) for the first object
E=extract(ùíÄ[1], (8, 12), (1, 128)) # Output a complex matrix

# mean AS in a TF region (8:12Hz and samples 1:128) for the two objects
ùê¶=mean(ùíÄ, (8, 12), (1, 128)) # Output a vector of complex numbers
# same computation without checking homogeneity of the two objects in ùíÄ (faster)
ùê¶=mean(ùíÄ, (8, 12), (1, 128); check=false)

# extract the AS in a TF region (8:12Hz and samples 1:128) for the two objects
ùêÑ=extract(ùíÄ, (8, 12), (8, 12)) # Output a vector of complex matrices

# plot the real part of the AS of x (see unit Plot.jl)
heatmap(Y, real)

# ...the imaginary part
heatmap(Y, imag)

# ...the amplitude
heatmap(Y, amplitude)

# or generate a TFAmplitude object from the AS
A=TFamplitude(Y)
# and plot it (with different colors)
heatmap(A; c=:fire)

# ...the amplitude of the AS smoothed in the frequency dimension
heatmap(smooth(hannSmoother, noSmoother, Y), amplitude)

# ...the amplitude of the AS smoothed in frequency and time
heatmap(smooth(hannSmoother, hannSmoother, Y), amplitude)

# ...the phase of the AS
heatmap(Y, phase)

# generate a TFPhase object
œ¥=TFphase(Y)
# and plot it (with custom colors)
heatmap(œ¥; c=:pu_or) # or, e.g., c=:bluesreds

# compute and plot phase in [0, 2œÄ]
heatmap(TFphase(Y; func=x-&gt;x+œÄ); c=:amp)

# compute and plot unwrapped phase
heatmap(TFphase(Y; unwrapped=true); c=:amp)

# smooth time-frequency AS: smooth frequency
Z=smooth(blackmanSmoother, noSmoother, Y)

# plot amplitude of smoothed analytic signal
heatmap(Z, amplitude)

# not equivalently (!), create an amplitude object and smooth it:
# in this case the amplitude is smoothed, not the AS
A=smooth(blackmanSmoother, noSmoother, TFamplitude(Y))
heatmap(A)

# Smoothing raw phase estimates is unappropriate
# since the phase is a discontinous function, however it makes sense
# to smooth phase if the phase is unwrapped.
heatmap(smooth(blackmanSmoother, noSmoother, TFphase(Y; unwrapped=true));
        c=:amp)

# smooth AS: smooth both frequency and time
E=smooth(blackmanSmoother, blackmanSmoother, Y)

# plot amplitude of smoothed analytic signal
heatmap(E, amplitude)

# plot phase of smoothed analytic signal
heatmap(E, phase) # bluesreds

# not equivalently (!), create amplitude and phase objects and smooth them
A=smooth(blackmanSmoother, blackmanSmoother, TFamplitude(Y))
heatmap(A)

œ¥=smooth(blackmanSmoother, blackmanSmoother, TFphase(Y, unwrapped=true))
heatmap(œ¥; c=:amp) # bluesreds

# smooth again
œ¥=smooth(blackmanSmoother, blackmanSmoother, œ¥)
heatmap(œ¥; c=:amp)
# and again ...

# create smoothed AS
Y=TFanalyticsignal(x, sr, t, bandwidht;
                   fmax=32,
                   fsmoothing=hannSmoother,
                   tsmoothing=hannSmoother)

# plot amplitude of smoothed analytic signal
heatmap(Y, amplitude)

A=TFamplitude(x, sr, t, bandwidht;
              fmax=32,
              fsmoothing=hannSmoother,
              tsmoothing=hannSmoother)

# plot smoothed amplitude
heatmap(A)

# compute a TFAnalyticSignal object with non-linear AS
Y=TFanalyticsignal(x, sr, t, bandwidht; fmax=32, nonlinear=true)

# check that it is non-linear
Y.nonlinear

# check that the amplitude is now 1.0 everywhere
norm(amplitude(Y.y)-ones(eltype(Y.y, size(Y.y)))) # must be zero

# plot non-linear phase
heatmap(Y, phase; c=:bkr)

# get the center frequencies of TFAmplitude object A
A.flabels

# extract the amplitude in a time-frequency region
extract(A, (2, 10), (1, 256)) # output a real matrix

# extract the amplitude in a time-frequency region at only one frequency
extract(A, 10, (1, 256)) # output a row vector

# extract the amplitude at one temporal sample at one frequency
extract(A, 10, 12) # or extract(A, 10.0, 12)

# extract amplitude at one temporal sample in a frequency region
extract(A, (10, 12), 12) # or extract(A, (10.0, 12.0), 12)

# extract amplitude at one temporal sample and all frequencies
extract(A, :, 12) # output a (column) vector

# compute the mean in a time-frequency region:
mean(A, (2, 10), (1, 256)) # output a real number
# is equivalent to (but may be less efficient than)
mean(extract(A, (2, 10), (1, 256)))

# using column sign for extracting all time samples
extract(A, (2, 10), :)

# This:
extract(A, :, :)
# is equivalent to this:
A.y
# but if you don&#39;t need to extract all frequencies,
# use the extract function to control what frequencies will be extracted:
# This
extract(A, (4, 5), 10)
# is not equivalent to this
A.y[4:5, 10]
# since the `extract` function finds the correct rows corresponding
# to the sought frequencies (in Hz), while A.y[4:5, 10]
# just returns the elements [4:5, 10] in the TF amplitude object

# Although the first center frequency in A is 2Hz, its
# band-pass region is 1-3Hz, therefore the frequency range 1:10 is accepted
mean(A, (1, 10), (1, 256))
# but this result in an error (see the REPL) since 0.5 is out of range:
mean(A, (0.5, 10), (1, 256))

# using a colon sign for time range
a=mean(A, (1, 10), :)
# using an integer for time range (indicates one specific sample)
a=mean(A, (1, 10), 16)

# using a colon sign for frequency range
a=mean(A, :, (1, 16))
# using a real number for frequency range
a=mean(A, 8.5, (1, 16))

# NB: the `extract` and `mean` functions work with the same syntax
#     for objects TFAnayticSignal, TFAmplitude and TFPhase.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/47f99b0e274a636cc1b0432be7a8d18043ed3323/src/timefrequency.jl#L15-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.TFamplitude" href="#FourierAnalysis.TFamplitude"><code>FourierAnalysis.TFamplitude</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function TFamplitude(Z::TFAnalyticSignal;
                func::Function=identity)

(2)
function TFamplitude(ùêô::TFAnalyticSignalVector;
                func::Function=identity)

(3)
function TFamplitude(x         :: Vector{T},
                     sr        :: Int,
                     wl        :: Int,
                     bandwidht :: IntOrReal = 2;
                func       :: Function     = identity,
                filtkind   :: FilterDesign = Butterworth(2),
                fmin       :: IntOrReal    = bandwidht,
                fmax       :: IntOrReal    = sr√∑2,
                fsmoothing :: Smoother     = noSmoother,
                tsmoothing :: Smoother     = noSmoother,
                planner    :: Planner      = getplanner,
                ‚è©        :: Bool         = true) where T&lt;:Real =

(4)
function TFamplitude(ùê± :: Vector{Vector{T}},
                &lt; same arguments as method (3) &gt;</code></pre><p>(1)</p><p>Construct a <a href="#TFAmplitude-1">TFAmplitude</a> object computing the amplitude of <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> object <code>Z</code>. Optional keyword argument <code>func</code> is a function to be applied element-wise to the data matrix of the output. By default, the <code>identity</code> (do nothing) function is applied.</p><p>(2)</p><p>Construct a <a href="../MainModule/#TFAmplitudeVector-1">TFAmplitudeVector</a> object from a <a href="../MainModule/#TFAnalyticSignalVector-1">TFAnalyticSignalVector</a> object executing method (1) for all <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> objects in <code>ùêô</code></p><p>(3)</p><p>Call <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> to obtain the time-frequency analytic signal of real signal vector <code>x</code> and construct a <a href="#TFAmplitude-1">TFAmplitude</a> object holding the time-frequency amplitude (the mudulus, often referred to as the <em>envelope</em>) of <code>x</code>.</p><p>All arguments are used for regulating the estimation of the analytic signal, with the exception of <code>func</code>, <code>fsmoothing</code> and <code>fsmoothing</code>:</p><p><code>func</code> is an optional function to be applied to the amplitude data matrix output.</p><p>In order to estimate the analytic signal in the time-frequency domain this function calls the <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> constructor (method (1) therein), with both <code>fsmoothing</code> and <code>tsmoothing</code> arguments set to <code>noSmoother</code>. Arguments <code>fsmoothing</code> and <code>fsmoothing</code> are then used to smooth the amplitude.</p><p>In order to obtain amplitude estimations on smoothed analytic signal instead, create a <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> object passing a <a href="../MainModule/#Smoother-1">Smoother</a> to the <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> constructor and then use method (1) to obtain the amplitude. Such amplitude estimation can be further smoothed using the <a href="../tools/#FourierAnalysis.smooth"><code>smooth</code></a> function, as shown in the examples.</p><p>For the meaning of all other arguments, which are passed to function <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a>, see the documentation therein.</p><p>(4)</p><p>Construct a <a href="../MainModule/#TFAmplitudeVector-1">TFAmplitudeVector</a> object from a vector of real signal vectors <code>ùê±</code>, executing method (3) for all of them. In order to estimate the time-frequency analytic signal for a vector of signals, method (2) of <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> is called.</p><p><strong>See</strong>: <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a>, <a href="#TFAmplitude-1">TFAmplitude</a>.</p><p><strong>See also</strong>: <a href="../tools/#FourierAnalysis.amplitude"><code>amplitude</code></a>.</p><p><strong>Examples</strong>: see the examples of <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/47f99b0e274a636cc1b0432be7a8d18043ed3323/src/timefrequency.jl#L417-L500">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FourierAnalysis.TFphase" href="#FourierAnalysis.TFphase"><code>FourierAnalysis.TFphase</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">(1)
function TFphase(Z :: TFAnalyticSignal;
            func      :: Function = identity,
            unwrapped :: Bool     = false)

(2)
function TFphase(ùêô :: TFAnalyticSignalVector;
            func      ::Function = identity,
            unwrapped ::Bool     = false)

(3)
function TFphase(x         :: Vector{T},
                 sr        :: Int,
                 wl        :: Int,
                 bandwidht :: IntOrReal = 2;
           unwrapped  :: Bool         = false,
           func       :: Function     = identity,
           filtkind   :: FilterDesign = Butterworth(2),
           fmin       :: IntOrReal    = bandwidht,
           fmax       :: IntOrReal    = sr√∑2,
           nonlinear  :: Bool         = false,
           fsmoothing :: Smoother     = noSmoother,
           tsmoothing :: Smoother     = noSmoother,
           planner    :: Planner      = getplanner,
           ‚è©        :: Bool         = true) where T&lt;:Real

(4)
function TFphase(ùê± :: Vector{Vector{T}},
                &lt; same arguments as method (3) &gt;</code></pre><p>(1)</p><p>Construct a <a href="#TFPhase-1">TFPhase</a> object computing the phase of <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> object <code>Z</code>. By default the phase is represented in <span>$[‚àíœÄ, œÄ]$</span>.</p><p>If optional keyword argument <code>unwrapped</code> is true (false by defalut), the phase is unwrapped, that is, it holds the cumulative sum of the phase along the time dimension once this is represented in <span>$[0, 2œÄ]$</span>.</p><p>Optional keyword argument <code>func</code> is a function to be applied element-wise to the data matrix of the output. By default, the <code>identity</code> (do nothing) function is applied. If <code>unwrapped</code> is true, the function is applied on the unwrapped phase.</p><p>(2)</p><p>Construct a <a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a> object from a <a href="../MainModule/#TFAnalyticSignalVector-1">TFAnalyticSignalVector</a> object executing method (1) for all <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> objects in <code>ùêô</code></p><p>(3)</p><p>Call <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> to obtain the time-frequency analytic signal of real signal vector <code>x</code> and construct a <a href="#TFPhase-1">TFPhase</a> object holding the time-frequency phase (argument) of <code>x</code>.</p><p>All arguments are used for regulating the estimation of the analytic signal, with the exception of <code>unwrapped</code>, <code>func</code>, <code>fsmoothing</code> and <code>fsmoothing</code>.</p><p><code>unwrapped</code> has the same meaning as in method (1) and (2).</p><p><code>func</code> is an optional function to be applied to the phase data matrix output. If <code>unwrapped</code> is true, it is applied to the unwrapped phase.</p><p>In order to estimate the analytic signal in the time-frequency domain this function calls the <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> constructor (method (1) therein), with both <code>fsmoothing</code> and <code>tsmoothing</code> arguments set to <code>noSmoother</code>. <code>fsmoothing</code> and <code>fsmoothing</code> are then used to smooth the phase if <code>unwrapped</code> is true.</p><p>In order to obtain phase estimations on smoothed analytic signal instead, create a <a href="#TFAnalyticSignal-1">TFAnalyticSignal</a> object passing a <a href="../MainModule/#Smoother-1">Smoother</a> to the <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> constructor and then use method (1) to obtain the phase.</p><p>For the meaning of all other arguments, which are passed to function <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a>, see the documentation therein.</p><p>(4)</p><p>Construct a <a href="../MainModule/#TFPhaseVector-1">TFPhaseVector</a> object from a vector of real signal vectors <code>ùê±</code>, executing method (3) for all of them. In order to estimate the time-frequency analytic signal for a vector of signals, method (2) of <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> is called.</p><p><strong>See</strong>: <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a>, <a href="#TFPhase-1">TFPhase</a>.</p><p><strong>See also</strong>: <a href="../tools/#FourierAnalysis.phase"><code>phase</code></a>, <a href="../tools/#FourierAnalysis.unwrapPhase"><code>unwrapPhase</code></a>, <a href="../tools/#FourierAnalysis.polar"><code>polar</code></a>.</p><p><strong>Examples</strong>: see the examples of <a href="#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/47f99b0e274a636cc1b0432be7a8d18043ed3323/src/timefrequency.jl#L579-L674">source</a></section><footer><hr/><a class="previous" href="../goertzel/"><span class="direction">Previous</span><span class="title">Goertzel&#39;s Algorithms</span></a><a class="next" href="../timefrequencyuni/"><span class="direction">Next</span><span class="title">TF Univariate Measures</span></a></footer></article></body></html>
