<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tools · FourierAnalysis</title><meta name="title" content="Tools · FourierAnalysis"/><meta property="og:title" content="Tools · FourierAnalysis"/><meta property="twitter:title" content="Tools · FourierAnalysis"/><meta name="description" content="Documentation for FourierAnalysis."/><meta property="og:description" content="Documentation for FourierAnalysis."/><meta property="twitter:description" content="Documentation for FourierAnalysis."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="FourierAnalysis logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="FourierAnalysis logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FourierAnalysis</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">FourierAnalysis Documentation</a></li><li><a class="tocitem" href="../MainModule/">Main Module</a></li><li><a class="tocitem" href="../tapers/">Tapering Windows</a></li><li><span class="tocitem">frequency domain</span><ul><li><a class="tocitem" href="../spectra/">Spectral Estimations</a></li><li><a class="tocitem" href="../crossspectra/">Cross-Spectral Matrices</a></li><li><a class="tocitem" href="../coherence/">Coherence Matrices</a></li><li><a class="tocitem" href="../goertzel/">Goertzel&#39;s Algorithms</a></li></ul></li><li><span class="tocitem">time-frequency(TF) domain</span><ul><li><a class="tocitem" href="../timefrequency/">TF Representations</a></li><li><a class="tocitem" href="../timefrequencyuni/">TF Univariate Measures</a></li><li><a class="tocitem" href="../timefrequencybi/">TF Bivariate Measures </a></li></ul></li><li><span class="tocitem">utilities</span><ul><li><a class="tocitem" href="../recipes/">Plots</a></li><li class="is-active"><a class="tocitem" href>Tools</a><ul class="internal"><li><a class="tocitem" href="#functions"><span>functions</span></a></li><li><a class="tocitem" href="#specific-methods"><span>specific methods</span></a></li><li><a class="tocitem" href="#generic-methods"><span>generic methods</span></a></li></ul></li><li><a class="tocitem" href="../fftw/">FFTW planners</a></li><li><a class="tocitem" href="../filters/">Filter Banks</a></li><li><a class="tocitem" href="../hilbert/">Hilbert Transform</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">utilities</a></li><li class="is-active"><a href>Tools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tools</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/FourierAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/master/docs/src/tools.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tools.jl"><a class="docs-heading-anchor" href="#tools.jl">tools.jl</a><a id="tools.jl-1"></a><a class="docs-heading-anchor-permalink" href="#tools.jl" title="Permalink"></a></h1><p>This unit implements</p><ul><li><a href="#functions">functions</a> that are useful when employing the FFT,</li><li><a href="#specific-methods">specific methods</a>: they apply to Julia&#39;s types or to single objects created by <em>FourierAnalysis</em>,</li><li><a href="#generic-methods">generic methods</a>: they apply to entire categories of objects created by <em>FourierAnalysis</em>.</li></ul><h2 id="functions"><a class="docs-heading-anchor" href="#functions">functions</a><a id="functions-1"></a><a class="docs-heading-anchor-permalink" href="#functions" title="Permalink"></a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.sinusoidal"><code>sinusoidal</code></a></td><td style="text-align: left">generate a sinusoidal wave</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.fres"><code>fres</code></a></td><td style="text-align: left">FFT frequency resolution</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.f2b"><code>f2b</code></a></td><td style="text-align: left">bin on a real-FFT vector best matching a frequency</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.b2f"><code>b2f</code></a></td><td style="text-align: left">frequency (in Hz) that correspond to a bin on a real-FFT vector</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.fdf"><code>fdf</code></a></td><td style="text-align: left">all Fourier discrete frequencies for a real-FFT</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.brange"><code>brange</code></a></td><td style="text-align: left">range of bins for a real-FFT vector covering all Fourier discrete frequencies</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.bbands"><code>bbands</code></a></td><td style="text-align: left">limits of all bandwidth-spaced band-pass regions of a real-FFT vectors, in bins</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.fbands"><code>fbands</code></a></td><td style="text-align: left">limits of all bandwidth-spaced band-pass regions of a real-FFT vectors, in frequencies (Hz)</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.decibel"><code>decibel</code></a></td><td style="text-align: left">convert a measure or a ratio between two measures into deciBels</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.sinusoidal" href="#FourierAnalysis.sinusoidal"><code>FourierAnalysis.sinusoidal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function sinusoidal(a :: IntOrReal,
                    f :: IntOrReal,
                   sr :: Int,
                    t :: Int,
                    θ :: IntOrReal = 0.;
                DClevel = 0.)</code></pre><p>Generate a sinusoidal wave with peak amplitude <code>a</code>, frequency <code>f</code>, sampling rate <code>sr</code>, duration (in samples) <code>t</code>, angle <code>θ</code> (θ=0 makes a sine, θ=π/2 makes a cosine) and optional keyword argument <code>DC</code> (float), the DC level defaulting to zero. It is adopted the convention that a sine wave starts at zero.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis, Plots

# create and plot a sinusoidal wave of 128 samples with
# peak amplitude 1, frequency 12Hz, sr=64, phase=π/2
v=sinusoidal(1., 12, 64, 128, π/2)
plot(v)

# estimate amplitude of a sinusoidal wave using Goertzel algorithm
f, sr, t = 32, 128, 128
v=sinusoidal(3., f, sr, t, 0)
c=goertzel(v, f, sr, t) # c should be equal to 0+3.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L15-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.fres" href="#FourierAnalysis.fres"><code>FourierAnalysis.fres</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function fres(sr :: Int,
              wl :: Int)</code></pre><p>FFT <strong>f</strong>requency <strong>res</strong>olution given sampling rate <code>sr</code> and window length <code>wl</code>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.f2b"><code>f2b</code></a>, <a href="#FourierAnalysis.b2f"><code>b2f</code></a>, <a href="#FourierAnalysis.fdf"><code>fdf</code></a>, <a href="#FourierAnalysis.brange"><code>brange</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis
fres(1024, 2048) # return 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L58-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.f2b" href="#FourierAnalysis.f2b"><code>FourierAnalysis.f2b</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function f2b(f :: IntOrReal,
            sr :: Int,
            wl :: Int;
        DC :: Bool = false)</code></pre><p><strong>f</strong>requency <strong>to b</strong>in. Return the bin (position) in a real-FFT vector best matching a frequency <code>f</code> (in Hz), given sampling rate <code>sr</code> and window length <code>wl</code>. The frequency can be given either as an integer or as a real number.</p><p>If the requested <code>f</code> is exactly in between two Fourier discrete frequencies, then the smallest of the two equidistant frequencies is returned.</p><p>The FFT vector is assumed to be 1-based (as always in Julia). If <code>DC</code> is false, the first discrete frequency is assumed to be at bin 1, otherwise the DC is assumed to be at bin 1 and the first discrete frequency at bin 2.</p><p>If <code>DC</code> is false return 0 for frequencies inferior to half the frequency resolution.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.fres"><code>fres</code></a>, <a href="#FourierAnalysis.b2f"><code>b2f</code></a>, <a href="#FourierAnalysis.fdf"><code>fdf</code></a>, <a href="#FourierAnalysis.brange"><code>brange</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis
f2b(10, 512, 1024) # return 20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L78-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.b2f" href="#FourierAnalysis.b2f"><code>FourierAnalysis.b2f</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function b2f(bin :: Int,
              sr :: Int,
              wl :: Int;
        DC :: Bool = false)</code></pre><p><strong>b</strong>in <strong>to f</strong>requency. Return the closest discrete Fourier frequency (in Hz) that corresponds to a bin (position) in a real-FFT vector, given sampling rate <code>sr</code> and window length <code>wl</code>. The FFT vector is assumed to be 1-based, as always in Julia.</p><p>If <code>DC</code> is false, the first discrete frequency is assumed to be at bin 1, otherwise the DC level is assumed to be at bin 1 and the first discrete frequency at bin 2.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.f2b"><code>f2b</code></a>, <a href="#FourierAnalysis.fres"><code>fres</code></a>, <a href="#FourierAnalysis.fdf"><code>fdf</code></a>, <a href="#FourierAnalysis.brange"><code>brange</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis
f2b(20, 512, 1024) # return 40
f2b(10, 128, 128) # return 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L119-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.fdf" href="#FourierAnalysis.fdf"><code>FourierAnalysis.fdf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function fdf(sr :: Int,
             wl :: Int;
          DC :: Bool = false)</code></pre><p>Return a vector with all <strong>F</strong>ourier <strong>d</strong>iscrete <strong>f</strong>requencies for a real-FFT, given sampling rate <code>sr</code> and window length <code>wl</code>. If <code>DC</code> is false, the first discrete frequency starts at bin (position) 1 and the length of the vector is <span>$wl÷2$</span> (integer division), otherwise the DC level is at position 1. and the length of the vector is <span>$(wl÷2)+1$</span>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.f2b"><code>f2b</code></a>, <a href="#FourierAnalysis.fres"><code>fres</code></a>, <a href="#FourierAnalysis.b2f"><code>b2f</code></a>, <a href="#FourierAnalysis.brange"><code>brange</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis
fdf(8, 16)
# return the 8-element Array{Float64,1}:
# [0.5, 1.0, 1.5, 2.0, 2.5, 3, 3.5, 4.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L154-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.brange" href="#FourierAnalysis.brange"><code>FourierAnalysis.brange</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function brange(wl :: Int;
             DC :: Bool = false)</code></pre><p>Return a range of bins for a real-FFT vector covering all Fourier discrete frequencies given window length <code>wl</code>.</p><p>If <code>DC</code> is false, the range is <span>$1:(wl÷2)$</span> (integer division), otherwise it is <span>$1:(wl÷2)+1$</span>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.f2b"><code>f2b</code></a>, <a href="#FourierAnalysis.fres"><code>fres</code></a>, <a href="#FourierAnalysis.b2f"><code>b2f</code></a>, <a href="#FourierAnalysis.fdf"><code>fdf</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis
brange(0.5, 8) # return 1:4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L182-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.bbands" href="#FourierAnalysis.bbands"><code>FourierAnalysis.bbands</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function bbands(sr :: Int,
                wl :: Int,
         bandwidth :: IntOrReal;
    DC :: Bool = false)</code></pre><p>Return a vector of integers holding the limits of all <code>bandwidth</code>-spaced band-pass regions of a real-FFT, in bins of discrete Fourier frequencies, from one to <span>$wl÷2$</span> (integer division).</p><p>This is used by function <a href="#FourierAnalysis.bands"><code>bands</code></a>.</p><p>To know the frequencies in Hz to which these bins correspond, call <a href="#FourierAnalysis.fbands"><code>fbands</code></a>.</p><p><strong>See</strong>: <a href="#FourierAnalysis.bands"><code>bands</code></a>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.fbands"><code>fbands</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis
bbands(128, 256, 16) # return [1, 32, 64, 96, 128]
fbands(128, 256, 16) # return [0.5, 16.0, 32.0, 48.0, 64.0]

bbands(128, 256, 16; DC=true) # return [2, 33, 65, 97, 129]
fbands(128, 256, 16; DC=true) # return [0.5, 16.0, 32.0, 48.0, 64.0]

bbands(128, 128, 16) # return [1, 16, 32, 48, 64]
fbands(128, 128, 16) # return [1.0, 16.0, 32.0, 48.0, 64.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L205-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.fbands" href="#FourierAnalysis.fbands"><code>FourierAnalysis.fbands</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function fbands(sr :: Int,
                wl :: Int,
         bandwidth :: IntOrReal;
      DC :: Bool = false)</code></pre><p>Return a vector of Frequencies (in Hz) to which the bins created by a call to function <a href="#FourierAnalysis.bbands"><code>bbands</code></a> with the same arguments correspond.</p><p><strong>See</strong>: <a href="#FourierAnalysis.bbands"><code>bbands</code></a>.</p><p><strong>See also</strong>: <a href="#FourierAnalysis.bands"><code>bands</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L254-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.decibel" href="#FourierAnalysis.decibel"><code>FourierAnalysis.decibel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function decibel(S :: Union{Real, AbstractArray{T}}) where T&lt;:Real

(2)
function decibel(S1 :: Union{Real, AbstractArray{T}},
            S2 :: Union{Real, AbstractArray{T}}) where T&lt;:Real</code></pre><p>Convert (1) a measure <code>S</code>, or (2) a ratio between two measures <code>S1</code>./<code>S2</code> into deciBels.</p><p>Input measures can be real numbers or real arrays of any dimensions.</p><p>For array input, the ratio and the conversion is computed element-wise.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis
v=sinusoidal(3., 1, 128, 256, 0)
s=spectra(v, 128, 256; func=decibel) # compute the spectra in dB
s.y # show the spectra

decibel(s.y)

decibel(10.0)

N=abs.(randn(3, 3))
decibel(N)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L274-L305">source</a></section></article><h2 id="specific-methods"><a class="docs-heading-anchor" href="#specific-methods">specific methods</a><a id="specific-methods-1"></a><a class="docs-heading-anchor-permalink" href="#specific-methods" title="Permalink"></a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.amplitude"><code>amplitude</code></a></td><td style="text-align: left">return the amplitude (modulus) of a complex number, complex array or <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> object</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.phase"><code>phase</code></a></td><td style="text-align: left">return the phase (argument) of a complex number, complex array or  <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> object</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.polar"><code>polar</code></a></td><td style="text-align: left">return the phase (argument) and amplitude (modulus) of a complex number, a complex array or <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> object</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.unwrapPhase"><code>unwrapPhase</code></a></td><td style="text-align: left">compute and unwrap the phase of a complex array, unwrap a real array holding phase in [−π, π], or construct a <a href="../timefrequency/#TFPhase">TFPhase</a> object with the phase unwrapped</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.isUnwrapped"><code>isUnwrapped</code></a></td><td style="text-align: left">return true if the phase of all objects in a <a href="../MainModule/#TFPhaseVector">TFPhaseVector</a> is unwrapped</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.amplitude" href="#FourierAnalysis.amplitude"><code>FourierAnalysis.amplitude</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function amplitude(c::Complex;
                        func::Function=identity) = func(abs(c))

(2)
function amplitude(A::AbstractArray{T};
                        func::Function=identity) where T&lt;:Complex

(3)
function amplitude(A::TFAnalyticSignal;
                        func::Function=identity)

(4)
function amplitude(𝐀::TFAnalyticSignalVector;
                        func::Function=identity)</code></pre><p>(1)</p><p>Return the amplitude (modulus) of a complex number. This corresponds to Julia&#39;s <a href="https://docs.julialang.org/en/v1/base/math/#Base.abs">abs</a> function. It is here provided for syntactic consistency with the following methods.</p><p>(2)</p><p>Return the amplitude of a complex array <code>Z</code>. Typically, <code>Z</code> holds analytic signal, in which case the output is the analytic (instantaneous) amplitude (also known as envelope). The output is a real array of the same size as <code>Z</code>.</p><p>(3)</p><p>Return a real matrix with the analytic (instantaneous) amplitude of the <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> object <code>Z</code>. The output is of the same size as the data field <code>Z.y</code>.</p><p>(4)</p><p>As (3), but return a vector of amplitude matrices for all <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> objects in 𝐀</p><p>~</p><p>In all methods if a function is provided by the optional keyword argument <code>func</code>, it is applied element-wise to the output. For example,</p><ul><li>passing <code>func=x-&gt;x^2</code> will return the power,</li><li>passing <code>func=x-&gt;log(x^2)</code> will return the log-power,</li><li>passing <code>func=x-&gt;decibel(x^2)</code> will return the power in deciBels.</li></ul><p><strong>See</strong>: <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis, Plots
x=sinusoidal(10, 2, 128, t*4, 0).*sinusoidal(10, 1, 128, t*4, 0)

# amplitude and phase of a vector using analytic signal standard method
y=analyticsignal(x)
a=amplitude(y)
ϕ=phase(y, func=x-&gt;(x+π)/2π*50)
plot([x, a, ϕ]; labels=[&quot;signal&quot;, &quot;amplitude&quot;, &quot;phase&quot;])

# see what happen if `x` contains energy in frequencies below sr/wl Hz
# (see documentation of `analyticSignal` function)
y=analyticsignal(x, 64)
a=amplitude(y)
ϕ=phase(y, func=x-&gt;(x+π)/2π*50)
plot([x, a, ϕ]; labels=[&quot;signal&quot;, &quot;amplitude&quot;, &quot;phase&quot;])

# unwrapped phase
# the line below will do nothing as argument `unwrapdims` is 0 by default
ϕ2=unwrapPhase(phase(y))
# this will do the job
ϕ2=unwrapPhase(phase(y); unwrapdims=1)
plot([x, a, ϕ2./25]; labels=[&quot;signal&quot;, &quot;amplitude&quot;, &quot;unwr. phase&quot;])

# amplitude from analytic signal of a data matrix holding multiple series
X=randn(t, 4)
Y=analyticsignal(X)
A=amplitude(Y)
plot(A[:, 1:2])

# phase
𝛷=phase(Y)
plot(𝛷[:, 1:1])

# unwrapped phase
𝛷2=unwrapPhase(𝛷; unwrapdims=1)
plot(𝛷2)

# phase represented in [-1, 1]
𝛷=phase(Y, func=x-&gt;(x+π)/2π)
plot(𝛷[:, 1:1])

# sine of the phase
𝛷=phase(Y, func=sin)
plot(𝛷[:, 1:1])

# get Amplitude and phase from analytic Signal
A, 𝛷=polar(Y)
A
𝛷</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L311-L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.phase" href="#FourierAnalysis.phase"><code>FourierAnalysis.phase</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function phase(z::Complex; func::Function=identity)

(2)
function phase(Z::AbstractArray{T};
                        unwrapdims::Int=0,
                        func::Function=identity) where T&lt;:Complex

(3)
function phase(Z::TFAnalyticSignal;
                        unwrapped::Bool=false,
                        func::Function=identity)

(4)
function phase(𝐙::TFAnalyticSignalVector;
                        unwrapped::Bool=false,
                        func::Function=identity)
</code></pre><p>(1)</p><p>Return the phase (argument) of a complex number. This corresponds to a standard <a href="https://en.wikipedia.org/wiki/Atan2">atan2</a> function. It is here provided for syntactic consistency with the following methods.</p><p>(2)</p><p>Return the phase of a complex array <code>Z</code>. Typically, <code>Z</code> holds analytic signal, in which case the output is the analytic (instantaneous) phase. The output is a real array of the same size as <code>Z</code>.</p><p>If optional keyword argument <code>unwrapdims</code> is &gt; 0, return the unwrapped phase along the <code>unwrapdims</code> dimension of the array. For example, if <code>Z</code> is a matrix, passing <code>unwrapdims=1</code> unwrap the phase indipendently along its columns.</p><p>(3)</p><p>Return a real matrix with the analytic (instantaneous) phase of the <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> object <code>Z</code>. The output is of the same size as the data field <code>Z.y</code>.</p><p>If optional keyword argument <code>unwrapped</code> is true, return the unwrapped phase along the time dimension of the analytic signal (dims=2).</p><p>(4)</p><p>As (3), but return a vector of phase matrices for all <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> objects in 𝚯.</p><p>~</p><p>In all methods by default the phase is returned in [−π, π]. If a function is provided by the optional keyword argument <code>func</code>, it is applied to the phase. For example</p><ul><li>passing <code>func=x-&gt;x+π</code> will return the phase in [0, 2π],</li><li>passing <code>func=x-&gt;x/π</code> will return the phase in [-1, 1],</li><li>passing <code>func=sin</code> will return the sine of the phase.</li></ul><div class="admonition is-info" id="Nota-Bene-981cd9811953070c"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-981cd9811953070c" title="Permalink"></a></header><div class="admonition-body"><p>If in method (2) <code>unwrapdims</code> is &gt;0 or in method (3) and (4) <code>unwrapped</code> is true, the function <code>func</code> is applied to the unwrapped phase.</p></div></div><p><strong>See</strong>: <a href="#FourierAnalysis.unwrapPhase"><code>unwrapPhase</code></a>, <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a>.</p><p><strong>Examples</strong>: see examples of <a href="#FourierAnalysis.amplitude"><code>amplitude</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L432-L501">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.polar" href="#FourierAnalysis.polar"><code>FourierAnalysis.polar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function polar(c::Complex)

(2)
function polar(Z::AbstractArray{T}) where T&lt;:Complex

(3)
function polar(Z::TFAnalyticSignal)
</code></pre><p>(1)</p><p>Return the amplitude (modulus) and phase (argument) of a complex number as a 2-tuple.</p><p>(2)</p><p>Return the amplitude and phase of a complex array <code>Z</code>. Typically, <code>Z</code> holds analytic signal, in which case return the analytic (instantaneous) amplitude and phase. The output is a tuple of two real arrays of the same size as data field <code>Z.y</code>.</p><p>(3)</p><p>Return the analytic (instantaneous) amplitude and phase of the <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> object <code>Z</code>. The output is a tuple of two real arrays of the same size as data field <code>Z.y</code>.</p><p>~</p><p>In all methods the phase is returned in [−π, π].</p><p><strong>See</strong>: <a href="#FourierAnalysis.amplitude"><code>amplitude</code></a>, <a href="#FourierAnalysis.phase"><code>phase</code></a>, <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a>.</p><p><strong>Examples</strong>: see examples of <a href="#FourierAnalysis.amplitude"><code>amplitude</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L516-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.unwrapPhase" href="#FourierAnalysis.unwrapPhase"><code>FourierAnalysis.unwrapPhase</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function unwrapPhase(Z::AbstractArray{T};
                                unwrapdims::Int=0) where T&lt;:Complex

(2)
function unwrapPhase(ϴ::AbstractArray{T};
                                unwrapdims::Int=0) where T&lt;:Real

(3)
unwrapPhase(ϴ::TFPhase) [constructor of a TFPhase object]

(4)
unwrapPhase(𝚯::TFPhaseVector) [constructor of a TFPhaseVector object]</code></pre><p>(1)</p><p>If optional keyword argument <code>unwrapdims</code> is &gt; 0, compute the phase (argument) from a <em>complex</em> array and unwrap it along the <code>unwrapdims</code> dimension, otherwise (default) return <code>Z</code>. Typically, <code>Z</code> holds analytic signal.</p><p>(2)</p><p>If optional keyword argument <code>unwrapdims</code> is &gt; 0, unwrap along the <code>unwrapdims</code> dimension a <em>real</em> array holding phase data in [−π, π], otherwise return <code>ϴ</code>.</p><p>(3)</p><p>Construct a <a href="../timefrequency/#TFPhase">TFPhase</a> object by unwrapping its phase along the time dimension and copying all other fields from the <code>ϴ</code> object. If <code>ϴ.func</code> is different from the <code>identity</code> (do nothing) function, return instead an error message.</p><p>(4)</p><p>As (3), but conctruct a <a href="../MainModule/#TFPhaseVector">TFPhaseVector</a> holding <a href="../timefrequency/#TFPhase">TFPhase</a> objects in 𝚯 with the phase unwrapped. <code>ϴ.func</code> must be the identity function for all ϴ ∈ 𝚯.</p><p>The unwrapped phase is defined as the cumulative sum of the phase (along the relevant dimension) once this is represented in [0, 2π].</p><p><strong>Examples</strong>: see examples of <a href="#FourierAnalysis.amplitude"><code>amplitude</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L572-L619">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.isUnwrapped" href="#FourierAnalysis.isUnwrapped"><code>FourierAnalysis.isUnwrapped</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function isUnwrapped(ϴ::TFPhase)

(2)
function isUnwrapped(𝚯::TFPhaseVector)</code></pre><p>(1) Return true if the TFPhase objects ϴ have the phase unwrapped.</p><p>(2) Return true if all TFPhase objects in 𝚯 have the phase unwrapped.</p><p><strong>See</strong>: <a href="#FourierAnalysis.unwrapPhase"><code>unwrapPhase</code></a>, <a href="../timefrequency/#TFPhase">TFPhase</a>, <a href="../MainModule/#TFPhaseVector">TFPhaseVector</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L745-L760">source</a></section></article><h2 id="generic-methods"><a class="docs-heading-anchor" href="#generic-methods">generic methods</a><a id="generic-methods-1"></a><a class="docs-heading-anchor-permalink" href="#generic-methods" title="Permalink"></a></h2><p><strong>Generic methods</strong> applying to <a href="../MainModule/#FDobjects">FDobjects</a>, <a href="../MainModule/#FDobjectsVector">FDobjectsVector</a>, <a href="../MainModule/#TFobjects">TFobjects</a> and <a href="../MainModule/#TFobjectsVector">TFobjectsVector</a>:</p><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.smooth"><code>smooth</code></a></td><td style="text-align: left">smooth the data across frequencies and/or across time</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.extract"><code>extract</code></a></td><td style="text-align: left">extract the data in a frequency or time-frequency region</td></tr><tr><td style="text-align: left"><a href="#Statistics.mean"><code>mean</code></a></td><td style="text-align: left">compute the mean in a frequency or time-frequency region</td></tr></table><p>¤</p><p><strong>Generic methods</strong> applying only to <a href="../MainModule/#FDobjects">FDobjects</a> and <a href="../MainModule/#FDobjectsVector">FDobjectsVector</a>:</p><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.bands"><code>bands</code></a></td><td style="text-align: left">Return band-pass average of spectral, cross-spectral or coherence estimates in equally spaced band-pass regions</td></tr></table><p>¤</p><p><strong>Generic methods</strong> applying to <a href="../MainModule/#FDobjectsVector">FDobjectsVector</a>, and <a href="../MainModule/#TFobjectsVector">TFobjectsVector</a>:</p><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.sameParams"><code>sameParams</code></a></td><td style="text-align: left">return true if the non-data fields of all objects in the vector have the same value</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.isLinear"><code>isLinear</code></a></td><td style="text-align: left">return true if all objects in the vector are linear</td></tr><tr><td style="text-align: left"><a href="#FourierAnalysis.isNonLinear"><code>isNonLinear</code></a></td><td style="text-align: left">return true if all objects in the vector are non-linear</td></tr></table><p>¤</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.smooth" href="#FourierAnalysis.smooth"><code>FourierAnalysis.smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function smooth(smoothing::Smoother,
                v::Vector{R}) where R&lt;:RealOrComplex


(2)
function smooth(smoothing::Smoother,
                X::Matrix{R}; dims::Int=1) where R&lt;:RealOrComplex

(2)
function smooth(smoother :: Smoother,
                S :: Union{FDobjects, FDobjectsVector})

(3)
function smooth(fsmoothing :: Smoother,
                tsmoothing :: Smoother,
                Y :: Union{TFobjects, TFobjectsVector})</code></pre><p>Apply a smoothing function of type <a href="../MainModule/#Smoother">Smoother</a> to</p><ul><li>(1) a vector of real or complex numbers,</li><li>(2) a real of complex matrix along dimension <code>dims</code> (default=1),</li><li>(3) a <a href="../MainModule/#FDobjects">FDobjects</a> or all objects in a <a href="../MainModule/#FDobjectsVector">FDobjectsVector</a>,</li><li>(4) a <a href="../MainModule/#TFobjects">TFobjects</a> or all objects in a <a href="../MainModule/#TFobjectsVector">TFobjectsVector</a>.</li></ul><p>Methods (1) and (2) are provided for low-level computations. Methods (3) and (4) are constructors; for all methods the output is always of the same type as the input.</p><p>Method (3) smooths across the frequency dimension:</p><ul><li>for <a href="../spectra/#Spectra">Spectra</a> objects this amounts to smoothing the column vectors in their <code>.y</code> field,</li><li>for <a href="../crossspectra/#CrossSpectra">CrossSpectra</a> and <a href="../coherence/#Coherence">Coherence</a> objects this amounts to smoothing adjacent matrices in their .y field.</li></ul><p>Method (4) smooths across the frequency dimension, time dimension or both. This amounts to smoothing across the column vectors (frequency) and/or row vectors (time) in the <code>.y</code> field of the object. A smoother must be specified for the frequency dimension (<code>fsmoothing</code>) and for the time dimension (<code>tsmoothing</code>). Either one may be <code>noSmoother</code>, but if the two are different from <code>noSmoother</code>, then they must be the same. If smoothing is requested in both the frequency and time dimension, then the data is smoothed first in the time then in the frequency dimension. For <a href="../timefrequency/#TFPhase">TFPhase</a> objects, smoothing is allowed only if the phase is unwrapped.</p><p>This function allow smoothing frequency domain and time-frequency domain objects after they have been created, however, smoothing can also be requested upon creation. For example, see the documentation of <a href="../spectra/#Spectra">Spectra</a>.</p><div class="admonition is-info" id="Nota-Bene-7de1cadf9285b0e1"><header class="admonition-header">Nota Bene<a class="admonition-anchor" href="#Nota-Bene-7de1cadf9285b0e1" title="Permalink"></a></header><div class="admonition-body"><p>For methods (1), (2) and (3), if <code>Smoother</code> is <code>noSmoother</code>, then the input is returned unchanged. For method (4) this is the case if both <code>fsmoother</code> and <code>tsmoother</code> are <code>noSmoother</code>.</p><p>The data input must hold in the concerned dimension at least three elements for applying an Hann or Hamming smoother and at least five elements for applying the Blackman smoother.</p></div></div><p><strong>Maths</strong></p><p>Smoothing of a series <span>$x$</span> composed of <span>$k$</span> elements is carried out at element <span>$i$</span> such as</p><p><span>$x_{i}=ax_{i-2}+bx_{i-1}+cx_{i}+bx_{i+1}+ax_{i+2}$</span>.</p><p>The coefficients are</p><table><tr><th style="text-align: center">smoothing window</th><th style="text-align: center">a</th><th style="text-align: center">b</th><th style="text-align: center">c</th></tr><tr><td style="text-align: center">Hann</td><td style="text-align: center">0</td><td style="text-align: center">0.25</td><td style="text-align: center">0.50</td></tr><tr><td style="text-align: center">Hamming</td><td style="text-align: center">0</td><td style="text-align: center">0.23</td><td style="text-align: center">0.54</td></tr><tr><td style="text-align: center">Blackman</td><td style="text-align: center">0.04</td><td style="text-align: center">0.25</td><td style="text-align: center">0.42</td></tr></table><p>For 3-point smoothers, the first point is smoothed as</p><p><span>$x_{1}=\frac{c}{b+c}x_{1} + \frac{b}{b+c}x_{2}$</span></p><p>and the last (the <span>$k^{th}$</span>) as</p><p><span>$x_{k}=\frac{c}{b+c}x_{k} + \frac{b}{b+c}x_{k-1}$</span>.</p><p>For 5-point smoothers, the first point is smoothed as</p><p><span>$x_{1}=\frac{c}{a+b+c}x_{1} + \frac{b}{a+b+c}x_{2} + \frac{a}{a+b+c}x_{3}$</span>,</p><p>the second as</p><p><span>$x_{2}=\frac{b}{a+2b+c}x_{1} + \frac{c}{a+2b+c}x_{2} + \frac{b}{a+2b+c}x_{3} + \frac{a}{a+2b+c}x_{4}$</span>,</p><p>the second to last as</p><p><span>$x_{k-1}=\frac{a}{a+2b+c}x_{k-3} + \frac{b}{a+2b+c}x_{k-2} + \frac{c}{a+2b+c}x_{k-1} + \frac{b}{a+2b+c}x_{k}$</span></p><p>and the last as</p><p><span>$x_{k}=\frac{a}{a+b+c}x_{k-2} + \frac{b}{a+b+c}x_{k-1} + \frac{c}{a+b+c}x_{k}$</span>.</p><p><strong>See</strong>: <a href="../MainModule/#Smoother">Smoother</a></p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis, Plots
sr, t, f, a = 128, 128, 10, 0.5
# create a sinusoidal superimposed to white noise
v=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)
# compute Amplitude Spectra
Σ=spectra(v, sr, t; func=√)
bar(Σ.y, labels=&quot;raw amplitude spectra&quot;)

#smooth spectra
Σ2=smooth(blackmanSmoother, Σ)
bar!(Σ2.y, labels=&quot;smoothed amplitude spectra&quot;)

# smooth cross-spectra (or coherence) matrices
X=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
S=crossSpectra(X, sr, t) # or coherence (X, sr, t)
# smooth the cross-spectra # or coherence
S2=smooth(blackmanSmoother, S)

# smooth time-frequency object
Y = TFanalyticsignal(v, sr, sr*4)
# smooth frequency
Z=smooth(blackmanSmoother, noSmoother, Y)
# plot amplitude of smoothed analytic signal
heatmap(Z, amplitude)

# smooth AS: smooth both frequency and time
E=smooth(blackmanSmoother, blackmanSmoother, Y)
# plot real part of smoothed analytic signal
heatmap(Z, real)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L862-L994">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.extract" href="#FourierAnalysis.extract"><code>FourierAnalysis.extract</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function extract(S :: FDobjects,
            frange :: fInterval)

(2)
function extract(𝐒 :: FDobjectsVector,
            frange :: fInterval;
        w :: Vector = [],
    check :: Bool   = true)

(3)
function extract(Y :: TFobjects,
            frange :: fInterval,
            trange :: tInterval)

(4)
function extract(𝒀 :: TFobjectsVector,
            frange :: fInterval,
            trange :: tInterval;
        w :: Vector = [],
    check :: Bool   = true)</code></pre><p><strong>alias</strong>: <code>extr</code></p><p>Extract data in a frequency region from <a href="../MainModule/#FDobjects">FDobjects</a> and data in a time-frequency region from <a href="../MainModule/#TFobjects">TFobjects</a>. The frequency and time region are indicated by <code>frange</code> and <code>trange</code>, which are of type <a href="../MainModule/#fInterval">fInterval</a> and <a href="../MainModule/#tInterval">tInterval</a>, respectively.</p><p>The input/output types of this function for a region with more then one frequency and more than one sample is reported in the following table:</p><table><tr><th style="text-align: center">method</th><th style="text-align: left">input object</th><th style="text-align: left">output</th></tr><tr><td style="text-align: center">(1.1)</td><td style="text-align: left"><a href="../spectra/#Spectra">Spectra</a></td><td style="text-align: left">a real matrix with spectra in <code>frange</code> arranged in columns¹</td></tr><tr><td style="text-align: center">(1.2)</td><td style="text-align: left"><a href="../crossspectra/#CrossSpectra">CrossSpectra</a></td><td style="text-align: left">a vector of complex matrices holding the cross-spectra in <code>frange</code>²</td></tr><tr><td style="text-align: center">(1.3)</td><td style="text-align: left"><a href="../coherence/#Coherence">Coherence</a></td><td style="text-align: left">a vector of real matrices holding the coherence in <code>frange</code>²</td></tr><tr><td style="text-align: center">(2.1)</td><td style="text-align: left"><a href="../MainModule/#SpectraVector">SpectraVector</a></td><td style="text-align: left">a vector of matrices of type (1.1)</td></tr><tr><td style="text-align: center">(2.2)</td><td style="text-align: left"><a href="../MainModule/#CrossSpectraVector">CrossSpectraVector</a></td><td style="text-align: left">a vector of vectors of type (1.2)</td></tr><tr><td style="text-align: center">(2.3)</td><td style="text-align: left"><a href="../MainModule/#CoherenceVector">CoherenceVector</a></td><td style="text-align: left">a vector of vectors of type (1.3)</td></tr><tr><td style="text-align: center">(3.1)</td><td style="text-align: left"><a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a></td><td style="text-align: left">a complex matrix holding the analytic signal in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(3.2)</td><td style="text-align: left"><a href="../timefrequency/#TFAmplitude">TFAmplitude</a></td><td style="text-align: left">a real matrix holding the amplitude in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(3.3)</td><td style="text-align: left"><a href="../timefrequency/#TFPhase">TFPhase</a></td><td style="text-align: left">a real matrices holding the phase in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(4.1)</td><td style="text-align: left"><a href="../MainModule/#TFAnalyticSignalVector">TFAnalyticSignalVector</a></td><td style="text-align: left">a vector of matrices of type (3.1)</td></tr><tr><td style="text-align: center">(4.2)</td><td style="text-align: left"><a href="../MainModule/#TFAmplitudeVector">TFAmplitudeVector</a></td><td style="text-align: left">a vector of matrices of type (3.2)</td></tr><tr><td style="text-align: center">(4.3)</td><td style="text-align: left"><a href="../MainModule/#TFPhaseVector">TFPhaseVector</a></td><td style="text-align: left">a vector of matrices of type (3.3)</td></tr></table><p>Legend: ¹ <em>each column refers to a time-series on which the spectra have been computed.</em> ² *depending on how the objects has been created, the matrices may be either Hermitian or LowerTriangular. See the documentation of <a href="../crossspectra/#CrossSpectra">CrossSpectra</a> and <a href="../coherence/#Coherence">Coherence</a>.</p><p>Note that depending on the arguments the type of the output may loose one or two dimensions. For instance,</p><ul><li>if the <a href="../spectra/#Spectra">Spectra</a> object holds only one spectrum, (1.1) will output a column vector and (2.1) a vector of column vectors.</li><li>if <code>frange</code> points to a single frequency, (1.1) will output a row vector and (2.1) a vector of row vectors.</li><li>if both the above two conditions hold, (1.1) will output a real number and (2.1) a vector.</li><li>if <code>frange</code> points to a single frequency, (1.2), (1.3) will output a matrix and (2.2), (2.3) a vector of matrices.</li><li>If <code>frange</code> points to a single frequency band, (3.1), (3.2), (3.3) will output a row vector and (4.1), (4.2), (4.3) a vector of row vectors.</li><li>If <code>trange</code> points to a single time sample, (3.1), (3.2), (3.3) will output a column vector and (4.1), (4.2), (4.3) a vector of column vectors.</li><li>if both the above two conditions hold, (3.1), (3.2), (3.3) will output a number and (4.1), (4.2), (4.3) a vector.</li></ul><p>Method (2) and (4) allows the following <em>optional keyword arguments</em>:</p><p><code>w</code>, a <span>$k$</span>-vector of non-negative integers or real numbers, where <span>$k$</span> is the numbers of objects hold in the input <a href="../MainModule/#FDobjectsVector">FDobjectsVector</a> or <a href="../MainModule/#TFobjectsVector">TFobjectsVector</a>. <code>w</code> is a vector of weights for the regions extracted from the input objects. By default, no weights are assigned.</p><p><code>check</code>, a boolean. If it is true (default), it is checked that the non-data fields of the input objects are all the same (for example, sampling rate, bandwidth, etc.). Set it to false to improve speed.</p><p><strong>See also</strong>: <a href="#Statistics.mean"><code>mean</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis

# example with univariate Spectra objects (one series -&gt; one spectrum)
sr, t, f, a = 128, 256, 10, 1
# create a sinusoidal superimposed to white noise
v=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)
# compute univariate spectra
Σ=spectra(v, sr, t)
# spectra in between 8Hz and 12Hz
s=extract(Σ, (8, 12))
# spectra in between 8Hz and 12.5Hz
s=extract(Σ, (8, 12.5))
# spectra at 10Hz
s=extract(Σ, 10) # or s=extract(S, (10, 10))
# these two expressions are equivalent: s=extract(Σ, :), s=Σ.y

# example with multivariate spectra (several series -&gt; several spectra)
Σ=spectra(hcat(v, v+randn(t*16)), sr, t)
# spectra in between 8Hz and 12Hz
S=extract(Σ, (8, 12))
# spectra at 10Hz
S=extract(Σ, 10)

# example with CrossSpectra objects (the same goes for Coherence objects)
X=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra(X, sr, t)
# cross-spectra in between 8Hz and 12Hz (Hermitian matrices)
S=extract(Σ, (8, 12))
Σ=crossSpectra(X, sr, t; tril=true)
# cross-spectra in between 8Hz and 12Hz (LowerTriangular matrices)
S=extract(Σ, (8, 12))

# example with multiple cross-spectra
X2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector
S=extract(Σ, (8, 12); w=[0.4, 0.6])
# now S[1] holds the cross-spectra in range 8-12Hz for X
# and S[2] holds the cross-spectra in range 8-12Hz for X2

# example with time-frequency objects
# (work in the same way for TFAnalyticSignal, TFAmplitude and TFPhase)
Y = TFanalyticsignal(v, sr, t)
# analytic signal within frequencies 8Hz and 12Hz and time samples 1 to 64.
AS=extract(Y, (8, 12), (1, 64))

# all analytic signal within frequencies 8Hz and 12Hz.
AS=extract(Y, (8.0, 12), :) # accept integers and reals for frequencies

# all analytic signal within time samples 1 to 64.
AS=extract(Y, :, (1, 64))

# example with multiple time-frequency objects
# (notice how the type of the output changes)
Y = TFanalyticsignal([v, v+randn(t*16)], sr, t)
AS=extract(Y, (8, 12), (1, 64))
AS=extract(Y, (8), :)
AS=extract(Y, 8, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L1135-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean" href="#Statistics.mean"><code>Statistics.mean</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
function mean(S :: FDobjects,
         frange :: fInterval)

(2)
function mean(𝐒 :: FDobjectsVector,
         frange :: fInterval;
        w :: Vector = [],
    check :: Bool   = true)

(3)
function mean(Y :: TFobjects,
         frange :: fInterval,
         trange :: tInterval)

(4)
function mean(𝒀 :: TFobjectsVector,
         frange :: fInterval,
         trange :: tInterval;
          w :: Vector = [],
      check :: Bool   = true)</code></pre><p>Return the mean of data in a frequency region from <a href="../MainModule/#FDobjects">FDobjects</a> and data in a time-frequency region from <a href="../MainModule/#TFobjects">TFobjects</a>. The frequency and time region are indicated by <code>frange</code> and <code>trange</code>, which are of type <a href="../MainModule/#fInterval">fInterval</a> and <a href="../MainModule/#tInterval">tInterval</a>, respectively.</p><p>The complete input/output types for this function is reported in the following table:</p><table><tr><th style="text-align: center">method</th><th style="text-align: left">input object</th><th style="text-align: left">output</th></tr><tr><td style="text-align: center">(1.1)</td><td style="text-align: left"><a href="../spectra/#Spectra">Spectra</a></td><td style="text-align: left">a vector holding the mean spectra in <code>frange</code>¹</td></tr><tr><td style="text-align: center">(1.2)</td><td style="text-align: left"><a href="../crossspectra/#CrossSpectra">CrossSpectra</a></td><td style="text-align: left">a complex matrix holding the mean cross-spectra in <code>frange</code>²</td></tr><tr><td style="text-align: center">(1.3)</td><td style="text-align: left"><a href="../coherence/#Coherence">Coherence</a></td><td style="text-align: left">a real matrix holding the mean coherence in <code>frange</code>²</td></tr><tr><td style="text-align: center">(2.1)</td><td style="text-align: left"><a href="../MainModule/#SpectraVector">SpectraVector</a></td><td style="text-align: left">a vector of vectors of type (1.1)</td></tr><tr><td style="text-align: center">(2.2)</td><td style="text-align: left"><a href="../MainModule/#CrossSpectraVector">CrossSpectraVector</a></td><td style="text-align: left">a vector of matrices of type (1.2)</td></tr><tr><td style="text-align: center">(2.3)</td><td style="text-align: left"><a href="../MainModule/#CoherenceVector">CoherenceVector</a></td><td style="text-align: left">a vector of matrices of type (1.3)</td></tr><tr><td style="text-align: center">(3.1)</td><td style="text-align: left"><a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a></td><td style="text-align: left">a complex number holding the mean analytic signal in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(3.2)</td><td style="text-align: left"><a href="../timefrequency/#TFAmplitude">TFAmplitude</a></td><td style="text-align: left">a real number holding the mean amplitude in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(3.3)</td><td style="text-align: left"><a href="../timefrequency/#TFPhase">TFPhase</a></td><td style="text-align: left">a real number holding the mean phase in [<code>frange</code>, <code>trange</code>]</td></tr><tr><td style="text-align: center">(4.1)</td><td style="text-align: left"><a href="../MainModule/#TFAnalyticSignalVector">TFAnalyticSignalVector</a></td><td style="text-align: left">a vector of numbers of type (3.1)</td></tr><tr><td style="text-align: center">(4.2)</td><td style="text-align: left"><a href="../MainModule/#TFAmplitudeVector">TFAmplitudeVector</a></td><td style="text-align: left">a vector of numbers of type (3.2)</td></tr><tr><td style="text-align: center">(4.3)</td><td style="text-align: left"><a href="../MainModule/#TFPhaseVector">TFPhaseVector</a></td><td style="text-align: left">a vector of numbers of type (3.3)</td></tr></table><p>legend: ¹<em>each element of the vector refers to a time-series on which the spectra have been computed.</em> ² <em>depending on how the objects has been created, the matrices may be either Hermitian or LowerTriangular.</em></p><p>Method (2) and (4) allows the following <em>optional keyword arguments</em>:</p><p><code>w</code>, a <span>$k$</span>-vector of non-negative integers or real numbers, where <span>$k$</span> is the numbers of objects hold in the input <a href="../MainModule/#FDobjectsVector">FDobjectsVector</a> or <a href="../MainModule/#TFobjectsVector">TFobjectsVector</a>. <code>w</code> is a vector of weights for the means extracted from the input objects. By default, no weights are assigned.</p><p><code>check</code>, a boolean. If it is true (default), it is checked that the non-data fields of the input objects are all the same (for example, sampling rate, bandwidth, etc.).</p><p><strong>See also</strong>: <a href="#FourierAnalysis.extract"><code>extract</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis, Plots

# example with univariate Spectra objects (one series -&gt; one spectrum)
sr, t, f, a = 128, 256, 10, 1
# create a sinusoidal superimposed to white noise
v=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)
# compute the spectrum
Σ=spectra(v, sr, t)
# mean spectrum in between 8Hz and 12Hz
s=mean(Σ, (8, 12))
# mean spectrum in between 8Hz and 12.5Hz
s=mean(Σ, (8, 12.5))

# example with multivariate spectra (several series -&gt; several spectra)
Σ=spectra(hcat(v, v+randn(t*16)), sr, t)
# mean spectra in between 8Hz and 12Hz
S=mean(Σ, (8, 12))
# mean spectra at 10Hz, i.e., the spectra at 10Hz
S=mean(Σ, 10)

# example with CrossSpectra objects (the same goes for Coherence objects)
X=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra(X, sr, t)
# mean cross-spectra in between 8Hz and 12Hz (an Hermitian matrix)
S=mean(Σ, (8, 12))
Σ=crossSpectra(X, sr, t; tril=true)
# mean cross-spectra in between 8Hz and 12Hz (a LowerTriangular matrix)
S=mean(Σ, (8.0, 12.0)) # accept integers and reals for frequencies

# example with multiple CrossSpectra objects
X2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector
S=mean(Σ, (8, 12); w=[0.4, 0.6])
# now S[1] will hold the mean cross-spectrum in range 8-12Hz for X
# and S[2] will hold the mean cross-spectrum in range 8-12Hz for X2

# example with time-frequency objects
# (work in the same way for TFAnalyticSignal, TFAmplitude and TFPhase)
Y = TFanalyticsignal(v, sr, t)
# mean analytic signal within frequencies 8Hz and 12Hz and time samples 1 to 64.
as=mean(Σ, (8, 12), (1, 64))
# mean analytic signal within frequencies 8Hz and 12Hz.
as=mean(Σ, (8, 12), :)
# mean analytic signal within time samples 1 to 64.
as=mean(Σ, :, (1, 64))

# example with multiple time-frequency objects
Y = TFanalyticsignal([v, v+randn(t*16)], sr, t)
AS=mean(Y, (8, 12), (1, 64))
# get the mean across TFobjects of those means
m=mean(mean(Y, (8, 12), (1, 64)))
AS=mean(Y, (8), :)
AS=mean(Y, 8, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L1285-L1403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.bands" href="#FourierAnalysis.bands"><code>FourierAnalysis.bands</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function bands(S :: Union{FDobjects, FDobjectsVector}
       bandwidth :: IntOrReal)</code></pre><p>Return band-pass average of spectral, cross-spectral or coherence estimates in equally spaced band-pass regions with the given <code>bandwidth</code>. <code>bandwidth</code> can be given as an integer or as a real number. See <a href="#FourierAnalysis.bbands"><code>bbands</code></a> for details on the definition of band-pass regions.</p><p>Band-pass average is not supported for time-frequency objects as for those objects a similar averaging is natively avaiable using argument <code>bandwidth</code> in their constructors.</p><p>The output of this function is as it follows:</p><ul><li>for univariate <a href="../spectra/#Spectra">Spectra</a> objects (i.e., those hodling one spectrum only), a real column vector,</li><li>for multivariate <a href="../spectra/#Spectra">Spectra</a> objects, a real matrix,</li><li>for <a href="../MainModule/#SpectraVector">SpectraVector</a> objects, a vector of the above,</li><li>for <a href="../crossspectra/#CrossSpectra">CrossSpectra</a> and <a href="../coherence/#Coherence">Coherence</a> objects, a vector of Hermitian or LowerTriangular matrices, depending on how the object has been cosntructed,</li><li>for <a href="../MainModule/#CrossSpectraVector">CrossSpectraVector</a> and <a href="../MainModule/#CoherenceVector">CoherenceVector</a> objects, a vector  of the above.</li></ul><p><strong>See</strong>: <a href="#FourierAnalysis.bbands"><code>bbands</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using FourierAnalysis, Plots

# example with univariate Spectra objects (one series -&gt; one spectrum)
sr, t, f, a = 128, 256, 10, 1
# create a sinusoidal superimposed to white noise
v=sinusoidal(a, f, sr, t*16, 0) + randn(t*16)
# compute the spectrum
Σ=spectra(v, sr, t)
# mean spectra in 2Hz-band-pass regions
b=bands(Σ, 2)
plot(b)

# example with multivariate spectra (several series -&gt; several spectra)
Σ=spectra(hcat(v, v+randn(t*16), v+randn(t*16) ), sr, t)
# mean spectra in 2Hz-band-pass regions for all time-series
b=bands(Σ, 2)
plot(b)
# plot mean spectra in 2Hz-band-pass regions for time-series 2 and 3 only
plot(bands(Σ, 2)[:, 2:3])

# example with CrossSpectra objects (the same goes for Coherence objects)
X=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra(X, sr, t)
# mean cross-spectra in 4Hz-band-pass regions
B=bands(Σ, 4)

# example with multiple CrossSpectra objects
X2=broadcast(+, v, randn(t*16, 3))*randn(3, 3)
Σ=crossSpectra([X, X2], sr, t) # this is a CrossSpectraVector
# mean cross-spectra in 4Hz-band-pass regions for all cross-spectra objects
B=bands(Σ, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L1516-L1574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.sameParams" href="#FourierAnalysis.sameParams"><code>FourierAnalysis.sameParams</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function sameParams(𝐒        :: FDobjectsVector,
                    funcname :: String)</code></pre><p>Return true if all objects in 𝐒 have the same <code>sr</code>, <code>wl</code>, <code>DC</code>, <code>taper</code>, <code>func</code>(only for <a href="../MainModule/#SpectraVector">SpectraVector</a> objects), <code>nonlinear</code> (only for <a href="../MainModule/#CrossSpectraVector">CrossSpectraVector</a> and <a href="../MainModule/#CoherenceVector">CoherenceVector</a>) and <code>smoothing</code> fields, otherwise print an error message pointing to the first field that is not identical in all objects and return <code>Nothing</code>. This method applies to all <a href="../MainModule/#FDobjectsVector">FDobjectsVector</a> types, that is, to <a href="../MainModule/#SpectraVector">SpectraVector</a>, <a href="../MainModule/#CrossSpectraVector">CrossSpectraVector</a> and <a href="../MainModule/#CoherenceVector">CoherenceVector</a>.</p><p><code>funcname</code> is an optional string that the user can provide. It is inserted into the error message to locate the part of the code that generated the error. By defalut, &quot;unknown&quot; is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L642-L661">source</a></section><section><div><pre><code class="language-julia hljs">function sameParams(𝒀        :: TFobjectsVector,
                    funcname :: String) =</code></pre><p>Return true if all objects in 𝒀 have the same <code>bandwidth</code>, <code>nonlinear</code>, <code>fsmoothing</code> and <code>tsmoothing</code> field, otherwise print an error message pointing to the first field that is not identical in all objects and return <code>Nothing</code>. This method applies to all <a href="../MainModule/#TFobjectsVector">TFobjectsVector</a> types, that is, <a href="../MainModule/#TFAnalyticSignalVector">TFAnalyticSignalVector</a>, <a href="../MainModule/#TFAmplitudeVector">TFAmplitudeVector</a> and <a href="../MainModule/#TFPhaseVector">TFPhaseVector</a>.</p><p><code>funcname</code> has the same meaning as in the previous method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L682-L695">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.isLinear" href="#FourierAnalysis.isLinear"><code>FourierAnalysis.isLinear</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function isLinear(𝒀::Union{FDobjectsVector, TFobjectsVector})</code></pre><p>Return true if all objects in <code>𝒀</code> are linear. By definition, <a href="../spectra/#Spectra">Spectra</a> and <a href="../timefrequency/#TFAmplitude">TFAmplitude</a> objects are linear. <a href="../crossspectra/#CrossSpectra">CrossSpectra</a>, <a href="../coherence/#Coherence">Coherence</a>, <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> and <a href="../timefrequency/#TFPhase">TFPhase</a> objects may be linear or non-linear.</p><p><strong>See</strong>:<a href="../MainModule/#FDobjectsVector">FDobjectsVector</a>, <a href="../MainModule/#TFobjectsVector">TFobjectsVector</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L710-L720">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FourierAnalysis.isNonLinear" href="#FourierAnalysis.isNonLinear"><code>FourierAnalysis.isNonLinear</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function isNonLinear(𝒀::Union{FDobjectsVector, TFobjectsVector})</code></pre><p>Return true if all objects in <code>𝒀</code> are non-linear. By definition, <a href="../spectra/#Spectra">Spectra</a> and <a href="../timefrequency/#TFAmplitude">TFAmplitude</a> objects are linear. <a href="../crossspectra/#CrossSpectra">CrossSpectra</a>, <a href="../coherence/#Coherence">Coherence</a>, <a href="../timefrequency/#TFAnalyticSignal">TFAnalyticSignal</a> and <a href="../timefrequency/#TFPhase">TFPhase</a> objects may be linear or non-linear.</p><p><strong>See</strong>:<a href="../MainModule/#FDobjectsVector">FDobjectsVector</a>, <a href="../MainModule/#TFobjectsVector">TFobjectsVector</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/66ca6eb4dc3157a97317a5b6b6f5d1e79d6126a6/src/tools.jl#L727-L738">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../recipes/">« Plots</a><a class="docs-footer-nextpage" href="../fftw/">FFTW planners »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 11 June 2025 08:28">Wednesday 11 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
