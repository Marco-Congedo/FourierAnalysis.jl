<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hilbert Transform ¬∑ FourierAnalysis</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FourierAnalysis logo"/></a><div class="docs-package-name"><span class="docs-autofit">FourierAnalysis</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">FourierAnalysis Documentation</a></li><li><a class="tocitem" href="../MainModule/">Main Module</a></li><li><a class="tocitem" href="../tapers/">Tapering Windows</a></li><li><span class="tocitem">frequency domain</span><ul><li><a class="tocitem" href="../spectra/">Spectral Estimations</a></li><li><a class="tocitem" href="../crossspectra/">Cross-Spectral Matrices</a></li><li><a class="tocitem" href="../coherence/">Coherence Matrices</a></li><li><a class="tocitem" href="../goertzel/">Goertzel&#39;s Algorithms</a></li></ul></li><li><span class="tocitem">time-frequency(TF) domain</span><ul><li><a class="tocitem" href="../timefrequency/">TF Representations</a></li><li><a class="tocitem" href="../timefrequencyuni/">TF Univariate Measures</a></li><li><a class="tocitem" href="../timefrequencybi/">TF Bivariate Measures </a></li></ul></li><li><span class="tocitem">utilities</span><ul><li><a class="tocitem" href="../recipes/">Plots</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../fftw/">FFTW planners</a></li><li><a class="tocitem" href="../filters/">Filter Banks</a></li><li class="is-active"><a class="tocitem" href>Hilbert Transform</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">utilities</a></li><li class="is-active"><a href>Hilbert Transform</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hilbert Transform</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/master/docs/src/hilbert.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="hilbert.jl"><a class="docs-heading-anchor" href="#hilbert.jl">hilbert.jl</a><a id="hilbert.jl-1"></a><a class="docs-heading-anchor-permalink" href="#hilbert.jl" title="Permalink"></a></h1><p>This unit implements analytic signal estimations using the <a href="../fftw/#fftw.jl">fftw.jl</a> unit for computing the <a href="https://en.wikipedia.org/wiki/Hilbert_transform">Hilbert transform</a></p><article class="docstring"><header><a class="docstring-binding" id="FourierAnalysis.analyticsignal" href="#FourierAnalysis.analyticsignal"><code>FourierAnalysis.analyticsignal</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">   (1)
   function analyticsignal( X  :: Union{Vector{T}, Matrix{T}},
                            wl :: Int     = size(X, 1);
                        nonlinear :: Bool    =  false,
                        planner   :: Planner =  getplanner,
                        ‚è©       :: Bool    =  true) where T&lt;:Real

   (2)
   function analyticsignal( ùêó      :: Vector{Matrix{T}},
                            wl     :: Int;
                        nonlinear  ::  Bool      =  false,
                        planner    ::  Planner   =  getplanner,
                        ‚è©        ::  Bool      =  true) where T&lt;:Real</code></pre><p>(1)</p><p>Compute the analytic signal(AS) of vector <code>X</code> or of all column vectors of matrix <code>X</code> via the FFT and iFFT procedure, as explained in Marple(1999). If <code>wl</code>=size(X, 1) (default), use the standard method passing to the FFT and iFFT all samples in <code>X</code> altogether, whereas if <code>wl</code>&lt;size(X, 1) a sliding-windows method is used (see below).</p><p>Return the analytic signal <code>ùëå</code>, a complex vector if <code>X</code> is a vector or a complex matrix holding in its columns the analytic signal of the columns of <code>X</code> if <code>X</code> is a matrix. <code>ùëå</code> has the same number of samples (rows) as <code>X</code>.</p><p>Contrarely to what is done in the <a href="https://github.com/JuliaDSP/DSP.jl">DSP</a> package, the DC level of the signal is removed, therefore, if the input signal features a non-zero DC level, the real part of the AS will be equal to the input signal with the DC level removed. The imaginary part of <code>ùëå</code> is the Hilbert transform of such no-DC <code>X</code>.</p><p>The sliding-windows AS allows an efficient estimation of the AS for vectors and matrices when they are very large; it proceeds computing the AS on 50% sliding overlapping windows and forming the AS by retaining the central half of each window. The number of points effectively used to obtain the final estimation is <span>$wl$</span>√∑2 (integer division). <code>wl</code> must be even for using this estimation. This procedure produces edge effects, thus the first and last <span>$wl√∑4$</span> samples of the AS estimation should be discarded. In practice, one requires the AS of a larger data segment and trims at least <span>$wl√∑4$</span> samples at the beginning and end of the estimation. This is done automatically by the <a href="../timefrequency/#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a> function.</p><p>Also, the sliding-windows AS method creates small discontinuities at sample <span>$wl$</span>√∑4 and then every <span>$wl$</span>√∑2 samples, therefore <span>$wl$</span> should be chosen as large as possible.</p><div class="admonition is-info"><header class="admonition-header">Nota Bene</header><div class="admonition-body"><p>In order to avoid FFT computation of very long epochs, if <code>wl</code> &gt; 2^14, then <code>wl</code> is set to 2^10. Below this limit, as long as the computations are feasable, use the standard method. If you absolutely need to use the sliding-windows method, see <a href="../MainModule/#window-length-in-FFTW">window length in FFTW</a> for setting efficiently argument <code>wl</code>.</p><p>The input signal should be previously band-pass or high-pass filtered so as not to contain frequency components below the first discrete Fourier frequency obtained with windows of <code>wl</code> samples, that is, below sr/wl Hz, where sr is the sampling rate.</p></div></div><p><strong>Optional Keyword Arguments</strong>:</p><p><code>nonlinear</code>, if true, the analytic signal is normalized so that its amplitude is <span>$1.0$</span> at all points. This allow non-linear univariate and bivariate estimations (see <a href="../timefrequencyuni/#timefrequencyuni.jl">timefrequencyuni.jl</a> and <a href="../timefrequencybi/#timefrequencybi.jl">timefrequencybi.jl</a>).</p><p><code>planner</code> is an instance of the <a href="../fftw/#FourierAnalysis.Planner"><code>Planner</code></a> object, holding the forward and backward FFTW plans used to compute the FFTs and the iFFTs. By default the planner is computed, but it can be passed as an argumet here if it is pre-computed. This is interesting if the <code>analyticsignal</code> function is to be invoked repeatedly.</p><p>if <code>‚è©</code> is true, the method is run in multi-threaded mode across the series in <code>X</code> if the number of series is at least twice the number of threads Julia is instructed to use. See <a href="../MainModule/#Threads">Threads</a>.</p><p>(2)</p><p>Compute the analytic signal for all <span>$k$</span> multivariate data matrices given as a vector of matrices <code>ùêó</code>. Return a vector of matrices hodling the corresponding analytic signals as in method (1). The FFT and iFFT plans are computed only once. The <span>$k$</span> matrices in <code>ùêó</code> may have different number of columns (i.e., different number of series) and different number of rows (samples). However, the number of rows must be larger than <code>wl</code> for all of them.</p><p>If <code>‚è©</code> is true, this method run in multi-threaded mode across the matrices in <code>ùêó</code> if the number of matrices is at least twice the number of threads Julia is instructed to use, otherwise it tries to run each analytic signal estimation in multi-threaded mode as per method (1). See <a href="../MainModule/#Threads">Threads</a>.</p><p>This function is called by the following functions operating on time-frequency reprsentations: <a href="../timefrequency/#FourierAnalysis.TFanalyticsignal"><code>TFanalyticsignal</code></a>, <a href="../timefrequency/#FourierAnalysis.TFamplitude"><code>TFamplitude</code></a>, <a href="../timefrequency/#FourierAnalysis.TFphase"><code>TFphase</code></a>, <a href="../timefrequencyuni/#FourierAnalysis.meanAmplitude"><code>meanAmplitude</code></a>, <a href="../timefrequencyuni/#FourierAnalysis.concentration"><code>concentration</code></a>, <a href="../timefrequencyuni/#FourierAnalysis.meanDirection"><code>meanDirection</code></a>, <a href="../timefrequencybi/#FourierAnalysis.comodulation"><code>comodulation</code></a>, <a href="../coherence/#FourierAnalysis.coherence"><code>coherence</code></a>.</p><p><strong>References</strong> Marple S.L. (1999) Computing the Discrete-Time Analytic Signal via FFT. IEEE Transactions on Signal Processing 47(9), 2600-3.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia">using FourierAnalysis, FFTW, LinearAlgebra, Statistics, Plots, DSP
t=128; lab=[&quot;x&quot;, &quot;real(y)&quot;, &quot;imag(y)&quot;]

# Analytic signal of one vector
x=sinusoidal(10, 2, 128, t, œÄ/2; DC=10) # cosine
y=analyticsignal(x)
# note that real(y) is x without the DC level, i.e., x=real(y)+DC
plot([x, real(y), imag(y)]; labels=lab)

# make a check
s=sinusoidal(10, 2, 128, t, 0) # sine
norm(s-imag(y)) # should be zero

# Analytic Signal by DSP.jl
y2=hilbert(x)
norm(s-imag(y2)) # should be zero
# DSP.jl does not remove the DC level
# thus x=real(y2) in this case
plot([x, real(y2), imag(y2)]; labels=lab)

# Analytic signal of multiple vectors
x=hcat(x, sinusoidal(10, 3, 128, t, œÄ/2; DC=10))
y=analyticsignal(x)

# sliding-windows analytic signal of one vector
# (note edge effects)
x=sinusoidal(10, 2, 128, t*4, œÄ/2; DC=0)
y=analyticsignal(x, t)
plot([x, real(y), imag(y)]; labels=lab)

# sliding-windows analytic signal of multiple vectors
x=hcat(x, sinusoidal(10, 3, 128, t*4, œÄ/2; DC=0))
y=analyticsignal(x, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/FourierAnalysis.jl/blob/f7138eb3dedeeea8f3b245bf846a927916dbb73d/src/hilbert.jl#L11-L157">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../filters/">¬´ Filter Banks</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 19 April 2021 09:46">Monday 19 April 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
